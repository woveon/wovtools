#!/usr/bin/env bash
FOLD=$(tput cols)
CLUSTER=
ECHOMODE=0
DOALL=1
SED=`which gsed`
HAS_SECRET=0
PROVIDERVARS=()
RANCLUSTER=0


function fWovEnvDisplayOptions()
{
  cat <<EOF | fold -w ${FOLD} -s


usage: `basename $0` [options]

Export the context as variables for scripts or export specific variables. 

This pulls config data from:
 - Wovtools project config (./wovtools/config.json)
 - Wovtools global config ($HOME/.wovtools)
 - K8s config
 - git

And secrets/config:
 - Wovtools project compiled secrets (./wovtools/cache/local/secrets.json)


Command Options:

  -h/--help     : display these options
  -v/--version  : version of wovtools
  --rcAWS       : convert a region code to an AWS code (ex. va-> us-east-1)
  --vh-label    : vh label in DockerHub repo
 
  Basic Environment Configuration:
  -g/--global X : target output for another context (not from Kubernetes)  NOTE: must be 1st param
  -e            : echo the output with newlines
  -E            : echo the output on one line (bash executable)
  -p/--provider : run cluster config as well (WAS -c/--cluster) FIXME|TODO

  Secrets/Config:
  --envs        : print all the configuration as environment variables (sep lines)
  --conf        : print all the configuration as environment variables (one line)
  --exports     : runs all the configuration as environment variables (no output, sourced)
  --var X       : print this variable X

  Kubernetes Generation 
    NOTE: These use Make to run a script... not good... need better way to run
  -c/--cluster X  : set the cluster to X (required for --cm/--se)
  --cm X          : only config used by plugin, (sep lines)
  --se X          : only secrets used by plugin, (sep lines)
  --CC            : cluster configuration

Example Usage:
  `basename $0`    : sets all environment variables
  `basename $0` -e : set and echo all environment variables
  `basename $0` --var X : set the env variable
  `basename $0` -e --var X : set and echo the env variable

EOF
}

if [ "$1" == '--help' ] || [ "$1" == '-h' ]; then fWovEnvDisplayOptions; exit 0; fi



# --------------------------------------------------------------------- 
# Calls wov-env-build to build the secretfile if it does not exist.
#  if $1 == force, force
# --------------------------------------------------------------------- 
function fBuildSecret
{ 
  if [ ! -f "${WOV_SECRETFILE}" ] || [ "$1" == "force" ]; then 
    echo "buidling"
    local G=
    if [ "${GLOBALCOMMAND}" != "" ]; then
      G="--global ${GLOBALCOMMAND} "
    fi
    wov-env-build ${G} --secrets ${CLUSTER}; 
  fi
}

# --------------------------------------------------------------------- 
# Sets the cluster we are generating environment vars for. By default,
# generates using settings in 'local', which is generated by 
# wov-env-build using the 'localcontext' entry. So, 'local' points to
# whatever cluster this project considers the localcontext.
# NOTE: creates the directory, but not file since that would look like 
#       it was current.
# --------------------------------------------------------------------- 
function doSetCluster
{
  CLUSTER=$1
  local WOV_SECRETFILE_path=${WOV_BASEDIR}/wovtools/cache/clusters/${CLUSTER}
  mkdir -m 700 -p ${WOV_SECRETFILE_path}
  WOV_SECRETFILE=${WOV_SECRETFILE_path}/secrets.json
  export WOV_SECRETFILE
}



# --------------------------------------------------------------------- 
# Load env
# --------------------------------------------------------------------- 
# NOTE: this passes arguments
. wov-env-loader
doSetCluster "local"


# ---------------------------------------------------------------------
# Ensure the SECRET_CACHE_DIR exists and is protected and then merge
# files config.json and local.json together in SECRETSMERGED_RAW
# if they have changed.
# ---------------------------------------------------------------------
mkdir -m 700 -p ${WOV_CACHEDIR}
if [ ! -f "${WOV_SECRETFILE}" ] || [ "${WOV_CONFIGFILE_MERGED}" -nt "${WOV_SECRETFILE}" ] || [ "${WOV_BASEDIR}/wovtools/secrets" -nt "${WOV_SECRETFILE}" ]; then
  fBuildSecret force 
  touch "${WOV_SECRETFILE}"

. wov-env-loader
fi



# --------------------------------------------------------------------- 
# For dev and prod, check local code and secrets are checked in and pushed.
# @param {bool} $1 - if true, allows for err msg and exit
# @return {bool} - 1 if error, 0 if ok
# --------------------------------------------------------------------- 
function doGitChecksOnFormalStages()
{
  local retval=1

  if [ "$WOV_STAGE" == "prod" ] || [ "$WOV_STAGE" == "dev" ]; then

    local R1=0
    wov-git-check ${WOV_BASEDIR}
    R1=$?
    if [ $R1 -eq 0 ]; then
      wov-git-check ${WOV_BASEDIR}/wovtools/secrets
      R2=$?
      if [ $R2 -eq 0 ]; then
        retval=0
      fi
    fi

    if [ $retval -ne 0 ]; then
      printf "\n\nERROR: failed git checks.\n\n"
      exit 1
    fi
  fi

  return $retval
}


# --------------------------------------------------------------------- 
# Used to generate the path where CLuster configuration would sit in 
# the archive.
#  ex. local path="`getRelativeArchivePath MyCluster`"
# --------------------------------------------------------------------- 
function getRelativeArchivePath()
{ 
  echo "${1}/${WOV_PROJECT}/${WOV_STAGE}/${WOV_PVER}_${WOV_SVER}" 
}


# --------------------------------------------------------------------- 
# $1 - cluster name
# $2 - append directory
# NOTE: NOT USED
# --------------------------------------------------------------------- 
function getClusterConfigPath()
{
  local CLUSTER=$1
  local APPENDPATH=$2
  local RETVAL="${WOV_BASEDIR}/wovtools/cache/clusters/${CLUSTER}"
  if [ "$APPENDPATH" != "" ]; then RETVAL="${RETVAL}/${APPENDPATH}"; fi
  echo $RETVAL
}

function doK8sBadContext()
{
  # Kubernetes Context in ~/.kube/config
  printf "\n***ERROR: bad WOV_CONTEXT of '${WOV_CONTEXT}'.\n\n"

  printf "...check kops clusters\n"
  if [ -z ${KOPS_STATE_STORE+x} ]; then 
    echo "WARNING: KOPS_STATE_STORE is unset... skipping cluster listing."
    echo "  - ex. export KOPS_STAGE_STORE='s3://kops.woveon.com'"
  else
    kops get clusters
  fi

  OLDIFS=$IFS
  IFS='.'
  local carray=( $WOV_FLAVOR )
  IFS=$OLDIFS
  WOVCONTEXTMAYBE="${WOV_CLTYPE}-${WOV_PROVIDER}-${WOV_REGION}-${carray[0]}"
  if [ "${#carray[@]}" != "1" ]; then
    echo "WARNING: WOV_FLAVOR of '${WOV_FLAVOR}' may be from the default kops. You probably need to create a WovTools context of '${WOVCONTEXTMAYBE}'."
  fi

  printf "...checking kubernetes context (cluster/user/namespace)\n"

  kubectl config get-clusters | \grep -- ${WOV_CLUSTER} > /dev/null
  if [ "$?" != "0" ]; then echo "  ... no cluster ${WOV_CLUSTER}"; else echo "  ... found cluster ${WOV_CLUSTER}."; fi

  kubectl config view | yaml json write - | jq -r '.users[].name' | \grep -- ${WOV_CONTEXT} > /dev/null 2>&1
  if [ "$?" != "0" ]; then 
    echo "  ... no user ${WOV_CONTEXT}"
  else
    echo "  ... found user ${WOV_CONTEXT}"
  fi

  kubectl get ns "${WOV_WPROJECT}-${WOV_GSTAGE}" > /dev/null 2>&1
  if [ "$?" != "0" ]; then 
    printf "  ... no kubernetes namespace '${WOV_WPROJECT}-${WOV_GSTAGE}'.\n"
    printf "    - create with: 'kubectl create namespace ${WOV_WPROJECT}-${WOV_GSTAGE}'.\n"
  else
    printf "  ... found kubernetes namespace '${WOV_WPROJECT}-${WOV_GSTAGE}'.\n"
  fi

  kubectl config get-contexts ${WOV_CLUSTER}-${WOV_WPROJECT}-${WOV_GSTAGE} 1> /dev/null 2>&1
  if [ "$?" == "0" ]; then 
    echo "  ... found context ${WOV_CLUSTER}-${WOV_WPROJECT}-${WOV_GSTAGE}"
  else
    echo "  ... no context ${WOV_CLUSTER}-${WOV_WPROJECT}-${WOV_GSTAGE}"
    kubectl config get-contexts ${WOVCONTEXTMAYBE} 1> /dev/null 2>&1
    if [ "$?" == "0" ]; then
      echo "  ... Oh hey, context '${WOVCONTEXTMAYBE}' exists... try 'kubectl config use-context ${WOVCONTEXTMAYBE}'?"
    fi
  fi


  exit 1
}



# vars from kops
# --------------------------------------------------------------------- 
if [ -z ${KOPS_STATE_STORE+x} ]; then 
  echo "ERROR: KOPS_STATE_STORE is unset. ex. export KOPS_STATE_STORE='s3://kops.woveon.com'"
  exit 1
fi


# --------------------------------------------------------------------- 
# Functions
# --------------------------------------------------------------------- 


# --------------------------------------------------------------------- 
# $1 - appending char(s): ex. ' ' or '\n'
# $2 - prepending char(s) : ex. 'export'
# --------------------------------------------------------------------- 
function fDoEcho() 
{
  local v=( 'WOV_VERSION' 'WOV_ME' 'WOV_BASEDIR' 'WOV_ARCHIVEREPOSITORY' 'WOV_ARCHIVEENV' 'WOV_CONTEXT' \
          'WOV_CLUSTER' 'WOV_NS' 'WOV_CLTYPE' 'WOV_PROVIDER' 'WOV_REGION' 'WOV_FLAVOR' 'WOV_PROJECT' \
          'WOV_KSTAGE' 'WOV_GSTAGE' 'WOV_STAGE' 'WOV_PVER' 'WOV_SVER' 'WOV_USERNAME' 'WOV_USEREMAIL' \
          'WOV_PROJECT' 'WOV_PROJECTTYPE' 'WOV_PROJECTTITLE' 'WOV_PROJECTDESCRIPTION' 'WOV_KPROJECT' \
          'WOV_WPROJECT' )

  for f in "${v[@]}"; do
    printf "$2$f='${!f}'$1"
  done
  if [ "$RANPROVIDER" == "1" ]; then doProviderEcho "$1"; fi
}


# --------------------------------------------------------------------- 
# TODO: fill this function in, and remove from WIAAS
#  NOTE: fills in REGIONVARS and exports variables as needed.
# --------------------------------------------------------------------- 
function fDoProvider() # Cluster()
{
  RANPROVIDER=1

  if [ "$WOV_PROVIDER" == "aws" ]; then . wov-env-aws; 
  else
    printf "\n\nERROR: Unknown provider to load env vars from : '${WOV_PROVIDER}'.\n\n"
    exit 1
  fi
}


# --------------------------------------------------------------------- 
# $1 - appending char(s): ex. ' ' or '\n'
# $2 - prepending char(s): ex. 'export '
# --------------------------------------------------------------------- 
function doProviderEcho
{
  for f in "${REGIONVARS[@]}"; do
    printf "$2$f='${!f}'$1"
  done
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doPrintVarX()
{
  if [ "$HAS_SECRET" == "0" ]; then fBuildSecret; fi
  R=`doPrintVarsENVS | grep "$1=" | cut -f2 -d"=" | ${SED} -e "s/^'//" -e "s/'$//"`
  if [ "$R" == "" ]; then
    R=${!1}
  fi
  echo $R
}

function doPrintVarsENVS()
{
  if [ "$HAS_SECRET" == "0" ]; then fBuildSecret; fi

  cat ${WOV_SECRETFILE} |
    jq  -r 'walk( if type == "object" then with_entries(select( .key | test("STAGE.+") or test("//*") | not)) else . end) | [leaf_paths as $path | {"key": $path | join("_"), "value": getpath($path)}] | from_entries | keys[] as $k | "WOV_\($k)=" + @sh "\(.[$k])" '

  if [ "$RANPROVIDER" == "1" ]; then doProviderEcho "\n"; fi

  HAS_BUILDENV=1
}

function doPrintVarsCONF()
{
  doPrintVarsENVS | tr '\n' ' '
}

function doPrintVarsEXPORTS()
{
  if [ "$HAS_SECRET" == "0" ]; then fBuildSecret; fi

  cat ${WOV_SECRETFILE} |
    jq  -r 'walk( if type == "object" then with_entries(select( .key | test("STAGE.+") or test("//*") | not)) else . end) | [leaf_paths as $path | {"key": $path | join("_"), "value": getpath($path)}] | from_entries | keys[] as $k | "export WOV_\($k)=" + @sh "\(.[$k])" '

  if [ "$RANPROVIDER" == "1" ]; then doProviderEcho "\n" "export "; fi

  HAS_BUILDENV=1
}

# --------------------------------------------------------------------- 
# Generate only the necessary env variables for microservices.
#  $1 - microservice name. ex. apisocket, apihal, etc.
#  $2 - "cm" or "se" for ConfigMap or Secrets
#  $3 - ?has newline? '1' puts on different lines, '0' all on same
# NOTE: This works by calling a javscript or shell script that 
#   generates the env vars. This script must end in 'js' or 'sh' and
#   be in ${1}/src/${1}config* or src/${1}config*.
# --------------------------------------------------------------------- 
function fConfGeneration()
{

  local R=

  # Read in envs
  if [ "${HAS_BUILDENV}" != "1" ]; then . <(doPrintVarsEXPORTS); fi

  # Get echo env vars, checking multiple locations
  if [ -e "${WOV_BASEDIR}/${1}/src/${1}config.js" ]; then
    local MSCFILE="${WOV_BASEDIR}/${1}/src/${1}config.js"
    if [ "$2" == "cm" ]; then 
      R=( $(node -e "console.log((new (require('${MSCFILE}'))())._genK8SConfigMap())") ) 
      RR=$?
    elif [ "$2" == "se" ]; then
      R=( $(node -e "console.log((new (require('${MSCFILE}'))())._genK8SSecrets())") )
      RR=$?
    fi
    if [ "${RR}" != "0" ]; then echo "ERROR: failed to generate '${1}' config from NodeJS source code."; exit 1 ; fi

  elif [ -e "${WOV_BASEDIR}/src/${1}config.js" ]; then
    local MSCFILE="${WOV_BASEDIR}/src/${1}config.js"
    if [ "$2" == "cm" ]; then
      R=( $(node -e "console.log((new (require('${MSCFILE}'))())._genK8SConfigMap())") ) 
      RR=$?
    elif [ "$2" == "se" ]; then 
      R=( $(node -e "console.log((new (require('${MSCFILE}'))())._genK8SSecrets())") ) 
      RR=$?
    fi
    if [ "${RR}" != "0" ]; then echo "ERROR: failed to generate '${1}' config from NodeJS source code."; exit 1 ; fi

  elif [ -e "${WOV_BASEDIR}/${1}/src/${1}config.sh" ]; then
    local MSCFILE="${WOV_BASEDIR}/${1}/src/${1}config.sh"
    R=( $(${MSCFILE} $2) )
    RR=$?
    if [ "${RR}" != "0" ]; then echo "ERROR: failed to generate '${1}' config from NodeJS source code."; exit 1 ; fi

  elif [ -e "${WOV_BASEDIR}/src/${1}config.sh" ]; then
    local MSCFILE="${WOV_BASEDIR}/src/${1}config.sh"
    R=( $(${MSCFILE} $2) )
    RR=$?
    if [ "${RR}" != "0" ]; then echo "ERROR: failed to generate '${1}' config from NodeJS source code."; exit 1 ; fi

  else
    (>&2 printf "\nERROR: could not find '${1}config.js'. Should be in ./src or ./${1}/src.\n\n")
    exit 1
  fi

#  R+=( WOV_STAGE=${WOV_STAGE} WOV_ME=${WOV_ME} )

#  echo "R: ${R[*]}"
  if [[ "${R[@]}" =~ "[WARN"  ]]; then
    echo "${R[*]}"
    printf "\n***ERROR(wov-env): warning message in generation of environment variables. Stopping.\n\n"
    exit 2
  fi

  local SEP=' '
  if [ "$3" == "1" ]; then SEP='\n'; fi

  for f in "${R[@]}"; do
    printf "$f$SEP"
  done
  #if [[ "${R[@]}" =~ "[WARN"  ]]; then
  #  printf "\n***ERROR(wov-env): warning message in generation of environment variables. Stopping.\n\n"
  #  exit 2
  #fi
}



# --------------------------------------------------------------------- 
# Command line processing
while [[ $1 =~ ^- ]]; do
  if [ "$1" == '-e' ]; then
    ECHOMODE=1
  elif [ "$1" == '-E' ]; then
    ECHOMODE=2

  elif [ "$1" == '-c' ] || [ "$1" == '--cluster' ]; then
    shift
    doSetCluster $1

  elif [ "$1" == '-p' ] || [ "$1" == '--provider' ]; then
    fDoProvider # Cluster

  elif [ "$1" == "--conf" ]; then
#    doLoadConf
    doPrintVarsCONF

  elif [ "$1" == "--envs" ]; then
#    doLoadEnv
    doPrintVarsENVS


    # print one var
  elif [ "$1" == "--env-var" ]; then
    shift
    if [ "$CLUSTER" == "" ]; then printf "\n\nERROR($(basename $0)): no cluster set. Use the '--cluster X' option.\n\n"; fi
    command grep -h ${1} ${WOV_BASEDIR}/wovtools/cache/clusters/${CLUSTER}/[cs][me]/*.json | ${SED} -e 's/^.*[=]//' -e 's/^"//' -e 's/"$//'

  elif [ "$1" == "--exports" ]; then
#    doLoadExports
    doPrintVarsEXPORTS

  elif [ "$1" == "--rcAWS" ]; then
    shift
    echo $(fConvertRegionCodeAWS $1)
    shift

  elif [ "$1" == "--cluster" ]; then
    shift
    CLUSTER=$1
    shift

  elif [ "$1" == "--CC" ]; then
    shift
    doCluster
    shift

  elif [ "$1" == "--cm" ]; then
    shift
    fConfGeneration $1 cm 1

  elif [ "$1" == "--se" ]; then
    shift
    fConfGeneration $1 se 1

  elif [ "$1" == "--CM" ]; then
    shift
    fConfGeneration $1 cm 0

  elif [ "$1" == "--SE" ]; then
    shift
    fConfGeneration $1 se 0

  elif [ "$1" == '--var' ]; then
    shift 
    V=$(doPrintVarX $1)
    if [ "$ECHOMODE" == "1" ]; then
      printf "$1=\"${V}\"\n"
    elif [ "$ECHOMODE" == "2" ]; then
      printf "$1=\"${V}\" "
    else
      echo ${V}
    fi
    DOALL=0
  elif [ "$1" == '-v' ] || [ "$1" == '--version' ]; then
    echo $WOV_VERSION

  elif [ "$1" == '--help' ] || [ "$1" == '-h' ]; then
    fWovEnvDisplayOptions
    exit 0
  else
    echo
    echo "***ERROR: unknown option '$1'."
    echo
    exit 1
  fi
  shift
done

# if user never asked to show any individual variables, show all
if [ "$DOALL" == "1" ]; then
  if   [ "$ECHOMODE" == "0" ]; then
    printf "" # do nothing
  elif [ "$ECHOMODE" == "1" ]; then
    fDoEcho "\n"
  elif [ "$ECHOMODE" == "2" ]; then
    fDoEcho " "
  else
    printf "\n\nERROR: Unknown echo mode '$ECHOMODE'.\n\n"
    exit 1
  fi
fi
