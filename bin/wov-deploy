#!/usr/bin/env bash


# --------------------------------------------------------------------- 
# Import Env 
# --------------------------------------------------------------------- 
wov-env-build -q --local
if [ "$?" != "0" ]; then exit 1; fi
deployenvargs=( "$@" )
set ""
. wov-env
. wov-ns-check
set -- "${deployenvargs[@]}"


DOECHO=1
DOFORCE=0
DORETAIN=0
FOLD=$(tput cols)
DRYRUN=0
CONFONLY=0
DEPLOYTYPE=
BUILDVH=1

#DEPLOYDIR=
DEPLOYCONF_EXT=

# Cache the current values
WOV_CUR_PVER=${WOV_PVER}
WOV_CUR_SVER=${WOV_SVER}

RECIPES=()
RECIPESCM=()
RECIPESSE=()



# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doAddLabels()
{
  # --------------------------------------------------------------------- 
  # Add labels
  if [ $DOECHO -ge 1 ]; then echo "... labeling namespace"; fi
  R=$(kubectl get namespaces | grep ${WOV_NS})
  if [ "$?" != "0" ]; then
    printf "\n\nERROR: missing namespace '${WOV_NS}'. Type : 'kubectl create namespace ${WOV_NS}' to create one.\n\n"
    exit 1
  fi
  printf "  ..."
  kubectl label --overwrite namespace ${WOV_NS} -v=0 WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
  if [ "$?" != "0" ]; then
    printf "\n\nERROR: failed to label namespace '${WOV_NS}'.\n"
    exit 1
  fi

   # --quiet=true
}


# Converts recipes into microservice names
#  $1 - directory with cm/se k8s files
#  $@ - named recipes, otherwise all from directory are used
function doBuildRecipes()
{
  # Files for Configmap and Secrets file
  CMDIR=${1}/cm
  SEDIR=${1}/se
  shift

  # New microservice for each container if you give them on the command line, or just read the directory
  RECIPES=( "$@" )
  if [ "${#RECIPES[@]}" == "0" ]; then
    #echo "CMDIR: ${CMDIR}"
  #  RECIPES=( $(cd ${WOV_BASEDIR}/wovtools/containers && find * -maxdepth 0 -type f 2> /dev/null) )
    RECIPESCM=( $(cd ${CMDIR} && find * -maxdepth 0 -type f 2> /dev/null) )
    RECIPESSE=( $(cd ${SEDIR} && find * -maxdepth 0 -type f 2> /dev/null) )
  else
    for f in "${RECIPES[@]}"; do
      RECIPESCM+=( "${WOV_PROJECT}${f}" )
      RECIPESSE+=( "${WOV_PROJECT}${f}" )
    done
    # RECIPESCM=$RECIPES
    # RECIPESSE=$RECIPES
  fi
  # echo "RECIPES: ${#RECIPES[@]} : ${RECIPES[@]}"
  # echo "RECIPESCM: ${#RECIPESCM[@]} : ${RECIPESCM[@]}"
  # echo "RECIPESSE: ${#RECIPESSE[@]} : ${RECIPESSE[@]}"

}


# --------------------------------------------------------------------- 
# Reads the files and creates ConfigMap and Secrets
#  $1 = deploy directory source (ex. ${WOV_CACHEDIR}/clusters/${WOV_CLUSTER}, or pulled from archive)
#  $2 = configuration (ConfigMap/Secret) extention (ex. 'vh' so for microservice 'apirest', creates 'apirestvh' )
#       NOTE: use 'null' for no extension (so it doesn't ignore "" passed in)
#  $* = recipes
# --------------------------------------------------------------------- 
function doDeployConf()
{
  local DEPLOYSRC=$1
  local CONFEXT=$2
  if [ "$CONFEXT" == "null" ]; then CONFEXT=""; fi
  shift
  shift

  echo "... deploy configmaps and secrets"

  doBuildRecipes ${DEPLOYSRC} $@

  # Add is project project level CM/SE
  RECIPESCM+=( "${WOV_PROJECT}" )
  RECIPESSE+=( "${WOV_PROJECT}" )

  # Create ConfigMap PLUGIN
  # --------------------------------------------------------------------- 
  for f in "${RECIPESCM[@]}"; do

    # local MSNAME=${WOV_PROJECT}${f}
    local MSNAME=${f}
    local CMFILE="${CMDIR}/${MSNAME}"          # full path to file
    # echo "CMFILE1: ${CMFILE}"

    # delete existing configmap
    kubectl delete configmap "${MSNAME}${CONFEXT}" > /dev/null 2>&1

    # if no configmap file, error out
    if [ ! -e "${CMFILE}" ]; then 
      # printf "\n\nERROR: no configmap '${MSNAME}${CONFEXT}', file ${CMFILE}. (RECIPES: '${RECIPES[@]}')\n\n"
      continue; 
    fi

    #echo "CMFILE: ${CMFILE}"
    # Convert X=Y into ConfigMap commands in DATA
    DATA=()
    while read l; do
      # echo ":$l"
      d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
      if [ "$d" != "" ]; then DATA+=("$d"); fi
    done <${CMFILE}

    # echo "DATA: ${DATA[@]}"
    printf "  ..."
    kubectl create configmap "${MSNAME}${CONFEXT}" "${DATA[@]}"
    if [ "$?" != "0" ]; then
      printf "\nERROR: failed creating ConfigMap '${MSNAME}${CONFEXT}' from '${CMFILE}'.\n"
      printf "CMFILE values: (should be 'k=v' format for K8s ConfigMap generation)\n"
      cat ${CMFILE}
      exit 1
    fi
  done


  # Create Secret PLUGIN
  # --------------------------------------------------------------------- 
  for f in "${RECIPESSE[@]}"; do

    #local MSNAME=${WOV_PROJECT}${f}${FILEEXT}
    local MSNAME=${f}${FILEEXT}
    local SEFILE="${SEDIR}/${MSNAME}"          # full path to file

    # delete existing secret
    kubectl delete secret "${MSNAME}${CONFEXT}" > /dev/null 2>&1 

    # if no secret file, continue on (not all have secrets)
    if [ ! -e "${SEFILE}" ]; then continue; fi

    # Convert X=Y into Secret commands in DATA
    DATA=()
    while read l; do
      #echo ":$l"
      d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
      if [ "$d" != "" ]; then DATA+=("$d"); fi
    done <${SEFILE}

    # Create and label secret
    printf "  ..."
    kubectl create secret generic "${MSNAME}${CONFEXT}" "${DATA[@]}"
    if [ "$?" != "0" ]; then
      printf "\nERROR: failed creating Secret '${MSNAME}${CONFEXT}' from '${SEFILE}'.\n"
      exit 1
    fi
    printf "  ..."
    kubectl label secret "${MSNAME}${CONFEXT}" --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
    if [ "$?" != "0" ]; then printf "\nWARNING: failed labeling '${MSNAME}${CONFEXT}'. CONTINUING...\n"; fi

  done

}


# --------------------------------------------------------------------- 
# If dev deploy, then might not have an image to use. test if aws image exists
# NOTE: only for AWS ECR... other Docker registries will be problematic...
#  $1 - recipe directory
#  $* - named containers (will check if 'deployment' or not to be safe)
# --------------------------------------------------------------------- 
function doCheckContainersExist()
{
  local imageissues=()

  if [ $DOECHO -ge 1 ]; then echo "... testing container images exist"; fi

  #local rdir=${WOV_CACHEDIR}/clusters/${WOV_CLUSTER}
  local rdir="$1"
  shift

  local containers=()

  # Build files to check for containers, from arguments or all directory files
  local k8sfiles=()
  if [ "$#" == "0" ]; then
    k8sfiles=( $(cd ${rdir} && ls *.yaml) ) ; k8sfilese=$?
    if [ $k8sfilese != 0 ]; then echo "ERROR: failed to find k8s files."; exit 1; fi
  else
    for f in ${*}; do
      k8sfiles+=( "deployment-${f}.yaml" )
      # k8sfiles+=( "${WOV_PROJECT}${f}.yaml" )
    done
  fi

  if [ $DOECHO -ge 2 ]; then echo "k8sfiles:  ${k8sfiles[@]}"; fi

  for f in ${k8sfiles[@]}; do
    # local k=`yaml get $f kind`
    # echo "  - file : ${f}"
    local k=`grep -i 'kind' $rdir/$f | sed 's/.*://g' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]'`
    if [ "$k" == "deployment" ]; then
      # NOTE: assume 1 container image in deployment
      local image=`yq r $rdir/$f spec.template.spec.containers[0].image`
      local kk=`basename ${image}`
      kk="${kk%:*}"
      containers+=("$kk")
      if [ ${DOECHO} -ge 2 ]; then printf "  ... check for container $kk\n"; fi
    fi
  done
#  echo "containers :  ${containers[@]}"

  for f in ${containers[@]}; do

#    echo "test container: $f"
    local img="${WOV_PROJECT}/${f}"
    local tag="${WOV_STAGE}_${WOV_PVER}"

    # test if image exists
    aws ecr list-images --repository-name ${img} --filter=tagStatus=TAGGED | jq '.imageIds[].imageTag' | grep "${tag}" > /dev/null
    if [ "$?" == "0" ]; then
      if [ ${DOECHO} -ge 1 ]; then printf "  ... container $f:${tag} exists\n"; fi
    else
      echo "***WARNING*** : image '${img}:${tag}' does not exist in AWS ECR! This will fail to load pod."
      imgissues+=( $f )
    fi
  done

  if [ "${#imgissues}" != "0" ]; then echo "" ; echo "  run (minus the '${WOV_PROJECT}'): 'wov-push-container ${imgissues[*]}'"; echo ""; fi
}


# --------------------------------------------------------------------- 
#  $1 - source directory
#  $* - specific k8s files to deploy. if none, deploy all in directory.
# --------------------------------------------------------------------- 
function doDeployK8s()
{
  local DEPLOYSRC=$1
  shift

  # Files for Configmap file
  K8SDIR=${DEPLOYSRC}/k8s

  # Deploy the k8s files
  if [ $DOECHO -ge 1 ]; then echo "... deploying Kubernetes"; fi
  if [ $DOECHO -ge 2 ]; then echo "  ... from ${K8SDIR}"; fi

  # If $# is not empty, then this is called with recipes, so convert those to files
  FILES=()
  if [ "$#" != "0" ]; then
    for r in ${@:1}; do
      echo "HERE: this makes assumptions about the names of these files... either skip that or do a grep for the deployment and name"
      FILES+=( "deployment-${r}" )
    done
  else
    # echo "k8sdir ${K8SDIR}"
    FILES=( $(cd ${K8SDIR} && ls *.yaml | sed -e 's/\(.*\)\..*/\1/') ) ; FILESe=$?
    if [ $FILESe != 0 ]; then echo "ERROR: failed to find files."; exit 1; fi
  fi

  # printf "K8S deployment FILES: ${FILES[*]}\n"

  for f in "${FILES[@]}"; do
    if [ ! -e ${K8SDIR}/$f.yaml ]; then
      printf "ERROR: unknown k8s file '$f.yaml' in ${K8SDIR}.\n"

      # NOTE: using ^ and $ for exact match of string
    elif [ "$(jq '.nodeploy[] | test("'"^${f}$"'")' ${WOV_CONFIGFILE_MERGED})" == "true" ]; then
      printf "  ...skipping '$f': as it is on the nodeploy list.\n"
    else
      printf "  ..."
      kubectl apply -f ${K8SDIR}/$f.yaml
    fi
  done
}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function fDisplayOptions()
{ 
  cat <<EOF | fold -w ${FOLD} -s


usage: `basename $0` [options] {files ...}

Deploys and updates a running kubernetes project, either from a specific and versioned push, or into a personal dev stage during development.

files   : all by default, or type them here and do individual only

 Deploy Types (one required):
  --dev   : Push current development environment to current development cluster (NOT PRODUCTION). 
  --stage : Proper call to roll a version to a stage in the cluster

 Deploy Options:
  --pver|--sver X : sets the Project and Secret version for roll-backs
  -f : force push
  --vh : build vh configuration (default)
  --VH : no build VH configuration
  -l   : list versions

 Utility:
  --check-containers : check that these containers exist in the container repository
  --conf-only : Only push configuration files (ConfigMaps and Secrets)
  --dry-run : pull files but don't deploy
  -r|--retain : retains the deployment values locally (potential security risk)
  -h : this help
  -q/-v : quiet/verbose


EOF
}




# ---------------------------------------------------------------------
# Push current development environment to cluster. 
# ---------------------------------------------------------------------
function doDeployDev()
{

  if [ ${WOV_STAGE} == 'prod' ] || [ ${WOV_STAGE} == 'dev' ]; then
    printf "\n\n\nERROR: deploying straight into stage ${WOV_STAGE} is not allowed. Do a 'wov-push' and then a 'wov-deploy --stage'.\n\n"
    exit 1
  fi

  if [ ${DOECHO} -ge 1 ]; then printf "... dev development\n"; fi

  # Ensure the cluster's environment (and vh if needed) is up to date
  if [ $DOECHO -ge 1 ]; then printf "  ... deploy cluster configuration '${WOV_CLUSTER}'.\n"; fi
  wov-env-build -q --cluster ${WOV_CLUSTER}
  if [ "$?" != "0" ]; then exit 1; fi
  if [ "$BUILDVH" == "1" ]; then 
    if [ $DOECHO -ge 1 ]; then printf "  ... deploy cluster configuration 'vh'.\n"; fi
    wov-env-build -q --cluster vh
    if [ "$?" != "0" ]; then exit 1; fi
  fi


  # Deploy to cluster, the relevant K8s "stuff"
  doDeployConf ${WOV_CACHEDIR}/clusters/${WOV_CLUSTER} "null" $*
  if [ "$BUILDVH" == "1" ]; then doDeployConf ${WOV_CACHEDIR}/clusters/vh "vh" $*; fi
  if [ "${CONFONLY}" == "0" ]; then

    # Add metadata
    doAddLabels

    # Update the cluster to current environments
    doDeployK8s ${WOV_CACHEDIR}/clusters/${WOV_CLUSTER} $*


    # Point to development containers and make sure they are available
    doPatchDeployments $*
    doCheckContainersExist ${WOV_CACHEDIR}/clusters/${WOV_CLUSTER}/k8s $*
  fi

}

function join_by { local IFS="$1"; shift; echo "$*"; }

# Patch deployemnts to point to STAGE_dev. each deployment overwrites this, so call each time to keep
function doPatchDeployments()
{
  if [ $DOECHO -ge 1 ]; then printf "... patching deployment to use '${WOV_STAGE}_dev' tagged containers.\n"; fi

  if [ ${WOV_STAGE} == 'prod' ]; then
    printf "\n\n\nERROR: patching straight into production is not allowed. Do a 'wov-push' and then a 'wov-deploy --stage'.\n\n"
    exit 1
  fi

  local DEPS=( "$@" )
  if [ "${#DEPS[@]}" == "0" ]; then
    DEPS=( $(cd ${WOV_BASEDIR}/wovtools/containers && find * -maxdepth 0 -type f 2> /dev/null) )
    # DEPS+=( "" )
  fi
  #local DEPS=( `kubectl get --no-headers=true deployments | awk '{print $1}'` )
  # echo "DEPS: '${DEPS[*]}'"

  # for each Deployment, patch it
  for c in "${DEPS[@]}"; do

    local d="${WOV_PROJECT}${c}"

    #echo "Deployment: $d, container: $c"

    # NOTE: using ^ and $ for exact match of string
    if [ "$(jq '.nodeploy[] | test("'"^${d}$"'")' ${WOV_CONFIGFILE_MERGED})" == "true" ]; then
      printf "...skipping patch of '$d': as it is on the nodeploy list.\n"
      continue
    fi

    # get container and remove trailing tag
    cntr_raw=$(kubectl get deployment $d -o json) ; cntr_rawe=$?
    if [ $cntr_rawe != 0 ]; then
      echo "ERROR: failed to find existing deployment to patch. Do a full deploy."
      exit 1
    fi
    cntr=$(echo ${cntr_raw} | jq -r '.spec.template.spec.containers[0].image')
    cntr_bits=(${cntr//:/ })
    #echo "${cntr_bits[@]}"
    unset 'cntr_bits[${#cntr_bits[@]}-1]'
    #echo "${cntr_bits[@]}"
    cntr1=`join_by : ${cntr_bits}`
    #echo "  cntr1: ${cntr1}"
    cntr2="${cntr1}:${WOV_STAGE}_dev"
    #echo "  cntr2: ${cntr2}"

    # patch for ${STAGE}_dev containers for deployment
    local patchport="{ \"spec\" : { \"template\" : { \"spec\" : { \"containers\" : [{ \"name\" : \"$d\", \"image\" : \"${cntr2}\"}]}}}}"
    #printf "    ${patchport}\n"
    printf "  ..."
    kubectl patch deployment $d -p "$patchport"
    A=$?
    if [[ $A == 0 ]]; then
      if [ $DOECHO -ge 2 ]; then printf "    ... patch success\n"; fi
      RETVAL=0
    elif [[ $A == 1 ]]; then
      if [ $DOECHO -ge 2 ]; then printf "    ... not patched\n"; fi
      RETVAL=0
    else
      if [ $DOECHO -ge 2 ]; then printf "    ... patch failed (error code $A)\n"; fi
      RETVAL=1
  fi
  done
}

# ---------------------------------------------------------------------
# Proper roll to stage call
# ---------------------------------------------------------------------
function doDeployStage()
{
  # Little more feedback
  if [ "${WOV_CUR_PVER}" != "${WOV_PVER}" ] || [ "${WOV_CUR_SVER}" != "${WOV_SVER}" ]; then
    printf " deploying version: ${WOV_STAGE}_${WOV_PVER}_${WOV_SVER}\n"
  fi
  printf "\n"

#  # If deploying the latest PVER, check that all code is pushed to archive
#  if [ "${WOV_CUR_PVER}" == "${WOV_PVER}" ]; then
#    wov-git-check ${WOV_BASEDIR}
#    R1=$?
#    wov-git-check ${WOV_BASEDIR}/wovtools/secrets
#    R2=$?
#    if [ "$R1" != "0" ] || [ "$R2" != "0" ]; then exit 1; fi
#  fi
#  #printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"
#
#
#  # Push containers if deploying current
#  if [ "${WOV_CUR_SVER}" == "${WOV_SVER}" ]; then
#    echo "  ... pushing to archive"
#    wov-push-k8s -q
#    if [ "$?" != "0" ]; then exit 1; fi
#  fi
#
#  # If deploying the latest SVER, check that all env is pushed to archive
#  if [ "${WOV_CUR_SVER}" == "${WOV_SVER}" ]; then
#
#    # Ensure the cluster's environment (and vh if needed) is up to date
#    if [ $DOECHO -ge 1 ]; then printf "  ... build for cluster '${WOV_CLUSTER}'.\n"; fi
#    wov-env-build -q --cluster ${WOV_CLUSTER}
#    if [ "$?" != "0" ]; then exit 1; fi
#    if [ "$BUILDVH" == "1" ]; then 
#      if [ $DOECHO -ge 1 ]; then printf "  ... build for cluster 'vh'.\n"; fi
#      wov-env-build -q --cluster vh; 
#      if [ "$?" != "0" ]; then exit 1; fi 
#    fi
#
#  fi
#
#  if [ "${WOV_CUR_SVER}" != "${WOV_SVER}" ]; then
#    echo "ERROR: I don't think this below will work since it generates the Conf. "
#    echo "       It should just push the k8s configmaps, secrets and k8s yaml."
#    echo " TODO: Implement this"
#    exit 1
#  fi
#
#  # Check Containers exist
#  doCheckContainersExist
#
#  # Pull environment from the Archive (that was just built)
#  # --------------------------------------------------------------------- 
#  #local ARCHBASE="$(getRelativeArchivePath) ${WOV_CLUSTER}"
#  local ARCHBASE="$(getRelativeArchivePath ${WOV_CLUSTER})"
#  local DEPLOYSRC=${WOV_CACHEDIR}/.deployments/${ARCHBASE}.$$
#  mkdir -p ${DEPLOYSRC}
#  if [ "$?" != "0" ]; then exit 1; fi
#  chmod 700 ${DEPLOYSRC}
#  if [ "$?" != "0" ]; then exit 1; fi
#  echo "DEBUG PRINTONLY : aws s3 sync ${WOV_ARCHIVEENV}/${ARCHBASE} ${DEPLOYSRC}  --delete"
#  aws s3 sync ${WOV_ARCHIVEENV}/${ARCHBASE} ${DEPLOYSRC}  --delete
#
#  # 
#  if [ "${DRYRUN}" == "0" ]; then 
#    if [ "${CONFONLY}" == "1" ]; then
#      doDeployConf ${DEPLOYSRC} "null" $*
#    else
#      doAddLabels
#      doDeployConf ${DEPLOYSRC} "null" $*
#      doDeployK8s  ${DEPLOYSRC} $*
#      rm -Rf ${DEPLOYSRC}
#    fi
#  fi


  # Pull environment from the Archive (that was just built)
  # --------------------------------------------------------------------- 
  local ARCHBASE="$(getRelativeArchivePath ${WOV_CLUSTER})"
  local DEPLOYSRC=${WOV_CACHEDIR}/.deployments/${ARCHBASE}.$$
  mkdir -p ${DEPLOYSRC}
  if [ "$?" != "0" ]; then exit 1; fi
  chmod 700 ${DEPLOYSRC}
  if [ "$?" != "0" ]; then exit 1; fi

  if [ ${DOECHO} -ge 1 ]; then printf "...pulling deployment from Archive : '${WOV_ARCHIVEENV}/${ARCHBASE}'\n"; fi
  aws s3 sync --quiet  ${WOV_ARCHIVEENV}/${ARCHBASE} ${DEPLOYSRC}  --delete

  # Check Containers exist before deploying
  doCheckContainersExist ${DEPLOYSRC}/k8s $*

  if [ "${DRYRUN}" == "0" ]; then 
    if [ "${CONFONLY}" == "1" ]; then
      doDeployConf ${DEPLOYSRC} "null" $*
    else
      doAddLabels
      doDeployConf ${DEPLOYSRC} "null" $*
      doDeployK8s  ${DEPLOYSRC} $*
      rm -Rf ${DEPLOYSRC}
    fi
  fi

}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function doListVersions
{  
  l=${WOV_CLUSTER}
  #l=wov-aws-va-dog
  # echo "TOOD: put back to WOV_CLUSTER and not dog"
  #local extra=
  #if [ "${WOV_CUR_PVER}" != "${WOV_PVER}" ]; then
  #  extra="${WOV_PVER}"
  #else
  #  extra="*"
  #fi
  #if [ "${WOV_CUR_SVER}" != "${WOV_SVER}" ]; then
  #  extra="${extra}-${WOV_SVER}"
  #else
  #  extra="${extra}-*"
  #fi
  #echo "extra ${extra}"

  local vers=( $(aws s3 ls ${WOV_ARCHIVEENV}/${ARCHBASE}${l}/${WOV_PROJECT}/${WOV_STAGE}/ | awk '{print $2}') )

  for f in ${vers[@]}; do
    echo ${f%/}
  done

}


# ---------------------------------------------------------------------
# Handle Params
# ---------------------------------------------------------------------
while [[ $1 =~ ^- ]]; do

  if [ "$1" == "-q" ]; then
    shift
    DOECHO=0

  elif [ "$1" == "-v" ]; then
    shift
    DOECHO=2

  elif [ "$1" == "-f" ]; then
    shift
    DOFORCE=1

  elif [ "$1" == "-r" ] || [ "$1" == "--retain" ]; then
    shift
    DORETAIN=1

  elif [ "$1" == "--dry-run" ]; then
    shift
    DRYRUN=1

  elif [ "$1" == "--conf-only" ]; then
    shift
    CONFONLY=1


  elif [ "$1" == "--vh" ]; then
    shift
    BUILDVH=1
  elif [ "$1" == "--VH" ]; then
    shift
    BUILDVH=0


  elif [ "$1" == "-l" ]; then
    shift
    doListVersions
    exit 0

  elif [ "$1" == "--check-containers" ]; then
    shift
    doCheckContainersExist ${WOV_CACHEDIR}/clusters/${WOV_CLUSTER}/k8s $*
    exit 0



  elif [ "$1" == "--dev" ]; then
    shift
    DEPLOYTYPE=dev

  elif [ "$1" == "--stage" ]; then
    shift
    DEPLOYTYPE=stage

  elif [ "$1" == "--pver" ]; then
    shift
    WOV_PVER="$1"
    shift

  elif [ "$1" == "--sver" ]; then
    shift
    WOV_SVER="$1"
    shift

  elif [ "$1" == "-p" ] || [ "$1" == "--patch" ]; then
    shift
    DEPLOYTYPE=patch
    #doPatchDeployments

  elif [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    fDisplayOptions
    exit 0

  else
    echo
    echo "***ERROR: unknown option '$1'."
    echo
    fDisplayOptions
    exit 1
  fi
done


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
printf "\n"
figlet wov-deploy
printf " version: ${WOV_STAGE}_${WOV_CUR_PVER}_${WOV_CUR_SVER}\n"


if [ "${WOV_STAGE}" == "prod" ]; then
  printf "\n\n**** deploying to production *********************************\n\n"
  printf "   Are you sure? (yes|NO) "
  read A
  if [ "$A" == "yes" ] || [ "$A" == "YES" ]; then
    printf "  ... ok, continuing.\n"
  else
    printf "\n  ... stopping.\n"
    exit 1
  fi
fi

if [ "$#" != "0" ]; then
  printf " microservice recipes: ( $* )\n"
else
  printf " microservice recipes: ALL\n"
fi

if [ "${DEPLOYTYPE}" == "" ]; then
  echo ""
  echo "***ERROR deploy needs to specify incremental or full"
  echo "  --dev   [...] : just deploy to the current development environment target (non-production)"
  echo "  --stage [...] : deploy versioned system"
  echo "  --patch [...] : patch deployments to point to the STAGE_dev container (--dev does for its own deployments)"
  echo ""

elif [ "${DEPLOYTYPE}" == "dev" ]; then
  doDeployDev $*

elif [ "${DEPLOYTYPE}" == "patch" ]; then
  # Ensure the cluster's environment is up to date and send 
  wov-env-build --cluster ${WOV_CLUSTER}
  doPatchDeployments $*

elif [ "${DEPLOYTYPE}" == "stage" ]; then
  doDeployStage $*

fi

