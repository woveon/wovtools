#!/usr/bin/env bash


# --------------------------------------------------------------------- 
# Import Env 
# --------------------------------------------------------------------- 
if [ ! -z ${WOV_stagemod+x} ]; then
  printf "\nERROR: Can't have WOV_stagemod set when deploying content.\n\n"
  exit 1
fi
deployenvargs=( "$@" )
set ""
. wov-env
. wov-ns-check
set -- "${deployenvargs[@]}"

DOECHO=1
DOFORCE=0
DORETAIN=0
FOLD=$(tput cols)
DRYRUN=0
CONFONLY=0
DEPLOYTYPE=
BUILDVH=1

DEPLOYDIR=
DEPLOYCONF_EXT=

# Cache the current values
WOV_CUR_PVER=${WOV_PVER}
WOV_CUR_SVER=${WOV_SVER}



# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doAddLabels()
{
  # --------------------------------------------------------------------- 
  # Add labels
  if [ $DOECHO -ge 1 ]; then echo "... labeling namespace"; fi
  R=$(kubectl get namespaces | grep ${WOV_NS})
  if [ "$?" != "0" ]; then
    printf "\n\nERROR: missing namespace '${WOV_NS}'. Type : 'kubectl create namespace ${WOV_NS}' to create one.\n\n"
    exit 1
  fi
  kubectl label namespace ${WOV_NS} -v=0 --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
   # --quiet=true
}



# --------------------------------------------------------------------- 
# Reads the files and creates ConfigMap and Secrets
#  $1 = directory extention (ex. 'vh' so reads not conf/cm/X, but conf/cm/Xvh)
# --------------------------------------------------------------------- 
function doDeployConf()
{
  RECIPES=( "$@" )
  if [ "${#RECIPES[@]}" == "0" ]; then
    RECIPES=( $(cd ${WOV_BASEDIR}/wovtools/containers && find * -maxdepth 0 -type f 2> /dev/null) )
    RECIPES+=( "" )
  fi
  echo "RECIPES: ${RECIPES[@]}"

  # Files for Configmap file
  CMDIR=${WOV_BASEDIR}/wovtools/cache/conf/cm

  # Files for Secrets file
  SEDIR=${WOV_BASEDIR}/wovtools/cache/conf/se

  # Extention to ConfigMap/Secrets entry name (ex. "vh" or "" for nothing)
  FILEEXT=${DEPLOYCONF_EXT}

  # --------------------------------------------------------------------- 
  # Create ConfigMap PLUGIN
  # --------------------------------------------------------------------- 

  # Read files from directory (note the appended FILEEXT)
  #CMFILES=( $(cd ${CMDIR} && ls 2> /dev/null) )
  for f in "${RECIPES[@]}"; do

    local MSROOT=${WOV_PROJECT}${f}${FILEEXT}
    local CMFILE="${CMDIR}/${MSROOT}"          # full path to file

    # delete existing configmap
    kubectl delete configmap ${MSROOT} 2> /dev/null

    # if no configmap file, continue on
    if [ ! -e "${CMFILE}" ]; then continue; fi

    # Convert X=Y into ConfigMap commands in DATA
    DATA=()
    while read l; do
      #echo ":$l"
      d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
      if [ "$d" != "" ]; then DATA+=("$d"); fi
    done <${CMFILE}

    #echo "DATA: ${DATA[@]}"
    kubectl create configmap ${MSROOT} "${DATA[@]}"
    if [ "$?" != "0" ]; then
      printf "\nERROR: failed creating ConfigMap $f from '${CMFILE}'.\n"
      exit 1
    fi
  done


  # Create Secret PLUGIN
  # --------------------------------------------------------------------- 

  # Read files from directory (note the appended FILEEXT)
  #SEFILES=( $(cd ${SEDIR} && ls 2> /dev/null) )
  for f in "${RECIPES[@]}"; do

    local MSROOT=${WOV_PROJECT}${f}${FILEEXT}
    local SEFILE="${SEDIR}/${MSROOT}"          # full path to file

    # delete existing secret
    kubectl delete secret ${MSROOT} 2> /dev/null

    # if no secret file, continue on
    if [ ! -e "${SEFILE}" ]; then continue; fi

    # Convert X=Y into Secret commands in DATA
    DATA=()
    while read l; do
      #echo ":$l"
      d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
      if [ "$d" != "" ]; then DATA+=("$d"); fi
    done <${SEFILE}

    kubectl create secret generic ${MSROOT} "${DATA[@]}"
    if [ "$?" != "0" ]; then
      printf "\nERROR: failed creating Secret $MSROOT from '${SEFILE}'.\n"
      exit 1
    fi
    kubectl label  secret ${MSROOT} --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
    if [ "$?" != "0" ]; then
      printf "\nWARNING: failed labeling ${MSROOT}. CONTINUING...\n"
    fi
  done

}


# If dev deploy, then might not have an image to use. test if aws image exists
# NOTE: only for AWS ECR... other Docker registries will be problematic...
function doCheckContainersExist()
{
  local imageissues=()

  echo "... testing container images exist"
  if [ "${DEPLOYTYPE}" == "dev" ]; then

    for f in ${RECIPES}; do
      local img="${WOV_PROJECT}/${WOV_PROJECT}${f}"
      local tag="${WOV_STAGE}_${WOV_PVER}"

      # test if image exists
      aws ecr list-images --repository-name ${img} --filter=tagStatus=TAGGED | jq '.imageIds[].imageTag' | grep "${tag}" > /dev/null
      if [ "$?" != "0" ]; then
        echo "***WARNING*** : image '${img}:${tag}' does not exist in AWS ECR! This will fail to load pod."
        imgissues+=( $f )
      fi
    done

    if [ "${#imgissues}" != "0" ]; then echo "" ; echo "  run: 'wov-build-containers ${imgissues[*]}'"; echo ""; fi
  fi
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doDeployK8s()
{
  # --------------------------------------------------------------------- 
  # Deploy the k8s files
  if [ $DOECHO -ge 1 ]; then echo "... deploying Kubernetes"; fi
  if [ $DOECHO -ge 2 ]; then echo "  ... from ${DEPLOYDIR}/k8s"; fi

  # If $# is not empty, then this is called with recipes, so convert those to files
  if [ "$#" != "0" ]; then
    FILES=()
    local RECIPES=$*
    for r in "${RECIPES[@]}"; do
      FILES+=( "${WOV_PROJECT}$r" )
    done
  else
    FILES=( $(cd ${DEPLOYDIR}/k8s/ && ls *.yaml | sed -e 's/\(.*\)\..*/\1/') )
  fi

  # printf "K8S FILES: ${FILES[*]}\n"

  for f in "${FILES[@]}"; do
    if [ ! -e ${DEPLOYDIR}/k8s/$f.yaml ]; then
      printf "ERROR: unknown k8s file '$f.yaml'.\n"

    # NOTE: using ^ and $ for exact match of string
    elif [ "$(jq '.nodeploy[] | test("'"^${f}$"'")' ${WOV_BASEDIR}/wovtools/config.json)" == "true" ]; then
      printf "...skipping '$f': as it is on the nodeploy list in wovtools/config.json\n"
    else
      kubectl apply -f ${DEPLOYDIR}/k8s/$f.yaml
    fi
  done
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doCleanUp()
{
  # --------------------------------------------------------------------- 
  # Cleanup
  if [ ${DORETAIN} == 1 ]; then
    echo "... skipping cleanup"
  else
    rm -Rf ${DEPLOYDIR}
  fi

}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function fDisplayOptions()
{ 
  cat <<EOF | fold -w ${FOLD} -s


usage: `basename $0` [options] {files ...}

Deploys a running kubernetes project from an archive.

files : all by default, or type them here and do individual only

 Deploy Types (one required):
  --dev   : Push current development environment to cluster. 
  --stage : Proper call to roll a version to a stage in the cluster

 Deploy Options:
  --pver|--sver X : sets the Project and Secret version for roll-backs
  -f : force push
  --vh : build vh (default)
  --VH : no build VH

 Utility:
  --conf-only : Only push configuration files (ConfigMaps and Secrets)
  --dry-run : pull files but don't deploy
  -r|--retain : retains the deployment values locally (potential security risk)
  -h : this help
  -q/-v : quiet/verbose


EOF
}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
printf "\n"
figlet wov-deploy
printf " version: ${WOV_STAGE}_${WOV_CUR_PVER}_${WOV_CUR_SVER}\n"


if [ "${WOV_STAGE}" == "prod" ]; then
  printf "\n\n**** deploying to production *********************************\n\n"
  printf "   Are you sure? (yes|NO) "
  read A
  if [ "$A" == "yes" ] || [ "$A" == "YES" ]; then
    printf "  ... ok, continuing.\n"
  else
    printf "\n  ... stopping.\n"
    exit 1
  fi
fi


# ---------------------------------------------------------------------
# Push current development environment to cluster. 
# ---------------------------------------------------------------------
function doDeployDev()
{
  if [ ${WOV_STAGE} == 'prod' ]; then
    printf "\n\n\nERROR: deploying straight into production is not allowed. Do a 'wov-push' and then a 'wov-deploy --stage'.\n\n"
    exit 1
  fi

  # Clear them out
  echo "... removing old conf"
  rm ${WOV_BASEDIR}/wovtools/cache/conf/cm/* 2> /dev/null || true
  rm ${WOV_BASEDIR}/wovtools/cache/conf/se/* 2> /dev/null || true


  # Move to side current secrets, so can put back later
  #local CURWOVMOD=$(wov-mod --get-on)
  mv ${WOV_BASEDIR}/wovtools/cache/secrets/current.json ${WOV_BASEDIR}/wovtools/cache/secrets/current.json.$$
  touch ${WOV_BASEDIR}/wovtools/cache/secrets/current.json

  # Build standard conf files
  echo "... build conf files"
  {
    wov-mod -q --off ALL
    if [ "$?" != "0" ]; then exit 1; fi
    wov-build-conf -q --skip-push --nogitchecks $*
    if [ "$?" != "0" ]; then exit 1; fi
  }

  # Build vh config files
  echo "... build 'vh' conf files"
  if [ "$BUILDVH" == "1" ]; then
    wov-mod -q --on vh
    if [ "$?" != "0" ]; then
      echo "ERROR: no entry for vh. set that up in wovtools/config.json."
    fi

    # create the blank compoound files ( ex. {WOV_PROJECT}vh )
    VHcmFILE="${WOV_BASEDIR}/wovtools/cache/conf/cm/${WOV_PROJECT}vh"
    echo -n "" > ${VHcmFILE}
    chmod 600 ${VHcmFILE}
    VHseFILE="${WOV_BASEDIR}/wovtools/cache/conf/se/${WOV_PROJECT}vh"
    echo -n "" > ${VHseFILE}
    chmod 600 ${VHseFILE}

    # create individual files (or maybe just one compound)
    wov-build-conf -q --skip-push --allow-stagemods --nogitchecks --conf-ext "vh" $*
    if [ "$?" != "0" ]; then exit 1; fi

    # merge all cm files into one, so can be loaded as one file in vh
    VHcmFILES=$(cd ${WOV_BASEDIR}/wovtools/cache/conf/cm ; find * -maxdepth 0 -type f | \grep 'vh$')
    for f in ${VHcmFILES}; do
      if [ "$f" == "${WOV_PROJECT}vh" ]; then continue; fi   # skip compound file
      echo "  ... append file ${f} into ${VHcmFILE}"
      cat ${WOV_BASEDIR}/wovtools/cache/conf/cm/${f} >> ${VHcmFILE}
    done

    # sort and uniq the file to remove duplicates
    rm ${VHcmFILE}.1 >& /dev/null || true
    touch ${VHcmFILE}.1
    chmod 600 ${VHcmFILE}.1
    sort ${VHcmFILE} | uniq >> ${VHcmFILE}.1
    rm ${VHcmFILE}
    mv ${VHcmFILE}.1 ${VHcmFILE}

    # merge all those into one, so can be loaded as one file in vh
    VHseFILES=$(cd ${WOV_BASEDIR}/wovtools/cache/conf/se ; find * -maxdepth 0 -type f | \grep 'vh$')
    for f in ${VHseFILES}; do
      if [ "$f" == "${WOV_PROJECT}vh" ]; then continue; fi   # skip compound file
      echo "  ... append file ${f} into ${VHseFILE}"
      cat ${WOV_BASEDIR}/wovtools/cache/conf/se/${f} >> ${VHseFILE}
    done

    # sort and uniq the file to remove duplicates
    rm ${VHseFILE}.1 >& /dev/null || true
    touch ${VHseFILE}.1
    chmod 600 ${VHseFILE}.1
    sort ${VHseFILE} | uniq >> ${VHseFILE}.1
    rm ${VHseFILE}
    mv ${VHseFILE}.1 ${VHseFILE}

  fi

  # Return wov-mod status
  echo "... return env to previous state"
  #wov-mod -q --off ALL ${CURWOVMODS}
  mv ${WOV_BASEDIR}/wovtools/cache/secrets/current.json.$$ ${WOV_BASEDIR}/wovtools/cache/secrets/current.json

  DEPLOYDIR=${WOV_BASEDIR}/wovtools/cache

  # Depploy to cluster, the relevant K8s "stuff"
  if [ "${CONFONLY}" == "1" ]; then
    doDeployConf $*
    if [ "$BUILDVH" == "1" ]; then
      DEPLOYCONF_EXT=vh
      doDeployConf $*
      DEPLOYCONF_EXT=
    fi
  else
    doAddLabels
    doDeployConf $*
    if [ "$BUILDVH" == "1" ]; then
      DEPLOYCONF_EXT=vh
      doDeployConf $*
      DEPLOYCONF_EXT=
    fi
    doDeployK8s $*
    # doCleanUp // no cleanup in devdeploy
  fi

  doPatchDeployments $*

  doCheckContainersExist $*
}

function join_by { local IFS="$1"; shift; echo "$*"; }

# Patch deployemnts to point to STAGE_dev. each deployment overwrites this, so call each time to keep
function doPatchDeployments()
{
  if [ ${WOV_STAGE} == 'prod' ]; then
    printf "\n\n\nERROR: patching straight into production is not allowed. Do a 'wov-push' and then a 'wov-deploy --stage'.\n\n"
    exit 1
  fi

  local DEPS=( "$@" )
  if [ "${#DEPS[@]}" == "0" ]; then
    DEPS=( $(cd ${WOV_BASEDIR}/wovtools/containers && find * -maxdepth 0 -type f 2> /dev/null) )
    # DEPS+=( "" )
  fi
  #local DEPS=( `kubectl get --no-headers=true deployments | awk '{print $1}'` )
  echo "DEPS: '${DEPS[*]}'"

  # for each Deployment, patch it
  for c in "${DEPS[@]}"; do

    local d="${WOV_PROJECT}${c}"

    echo "Deployment: $d, container: $c"

    # get container and remove trailing tag
    cntr=`kubectl get deployment $d -o json | jq -r '.spec.template.spec.containers[0].image'`
    cntr_bits=(${cntr//:/ })
    #echo "${cntr_bits[@]}"
    unset 'cntr_bits[${#cntr_bits[@]}-1]'
    #echo "${cntr_bits[@]}"
    cntr1=`join_by : ${cntr_bits}`
    #echo "  cntr1: ${cntr1}"
    cntr2="${cntr1}:${WOV_STAGE}_dev"
    #echo "  cntr2: ${cntr2}"

    # patch for ${STAGE}_dev containers for deployment
    local patchport="{ \"spec\" : { \"template\" : { \"spec\" : { \"containers\" : [{ \"name\" : \"$d\", \"image\" : \"${cntr2}\"}]}}}}"
    #printf "    ${patchport}\n"
    kubectl patch deployment $d -p "$patchport"
    A=$?
    if [[ $A == 0 ]]; then
      printf "  ... patch success\n"
      RETVAL=0
    elif [[ $A == 1 ]]; then
      printf "  ... not patched\n"
      RETVAL=0
    else
      printf "  ... patch failed (error code $A)\n"
      RETVAL=1
  fi
  done
}

# ---------------------------------------------------------------------
# Proper roll to stage call
# ---------------------------------------------------------------------
function doDeployStage()
{
  # Little more feedback
  if [ "${WOV_CUR_PVER}" != "${WOV_PVER}" ] || [ "${WOV_CUR_SVER}" != "${WOV_SVER}" ]; then
    printf " deploying version: ${WOV_STAGE}_${WOV_PVER}_${WOV_SVER}\n"
  fi
  printf "\n"

  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"


  # If deploying the latest PVER, check that all code is pushed to archive
  if [ "${WOV_CUR_PVER}" == "${WOV_PVER}" ]; then
    wov-git-check ${WOV_BASEDIR}
    R1=$?
    wov-git-check ${WOV_BASEDIR}/wovtools/secrets
    R2=$?
    if [ "$R1" != "0" ] || [ "$R2" != "0" ]; then exit 1; fi
  fi
  #printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"

  # If deploying the latest SVER, check that all env is pushed to archive
  if [ "${WOV_CUR_SVER}" == "${WOV_SVER}" ]; then
    #  deployenvargs=( "$@" )
    #  set ""
    #  . wov-push-env -q
    #  set -- "${deployenvargs[@]}"
    wov-push-env -q
  fi

  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"

  ARCHBASE=${WOV_PROJECT}/${WOV_STAGE}/${WOV_PVER}_${WOV_SVER}

  printf "  ... ARCHBASE : ${ARCHBASE}"

  # --------------------------------------------------------------------- 
  # Make directory to put files
  DEPLOYDIR=${WOV_BASEDIR}/wovtools/cache/.deployments/${WOV_PVER}_${WOV_STAGE}_${WOV_SVER}.$$
  mkdir -p ${DEPLOYDIR}/conf/cm
  mkdir -p ${DEPLOYDIR}/conf/se
  mkdir -p ${DEPLOYDIR}/k8s
  chmod -R 700 ${DEPLOYDIR}


  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"

  # --------------------------------------------------------------------- 
  # Pull env files
  aws s3 sync ${WOV_ARCHIVEENV}/${ARCHBASE}/conf ${DEPLOYDIR}/conf  --delete
  aws s3 sync ${WOV_ARCHIVEENV}/${ARCHBASE}/k8s ${DEPLOYDIR}/k8s  --delete

  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"
#  local CMFILE=${DEPLOYDIR}/conf/cm
#  local SEFILE=${DEPLOYDIR}/conf/se

#  if [ ! -f "$CMFILE" ]; then 
#    printf "\nERROR: K8s ConfigMap file does not exist at : '${CMFILE}'.\n"
#    exit 1
#  fi
#  if [ ! -f "$SEFILE" ]; then 
#    printf "\nERROR: K8s Secret file does not exist at : '${SEFILE}'.\n"
#    exit 1
#  fi

  if [ "${DRYRUN}" == "0" ]; then 
    if [ "${CONFONLY}" == "1" ]; then
      doDeployConf $*
    else
      doAddLabels
      doDeployConf $*
      doDeployK8s $*
      doCleanUp
    fi
  fi

}


# ---------------------------------------------------------------------
# Handle Params
# ---------------------------------------------------------------------
while [[ $1 =~ ^- ]]; do

  if [ "$1" == "-q" ]; then
    shift
    DOECHO=0

  elif [ "$1" == "-v" ]; then
    shift
    DOECHO=2

  elif [ "$1" == "-f" ]; then
    shift
    DOFORCE=1

  elif [ "$1" == "-r" ] || [ "$1" == "--retain" ]; then
    shift
    DORETAIN=1

  elif [ "$1" == "--dry-run" ]; then
    shift
    DRYRUN=1

  elif [ "$1" == "--conf-only" ]; then
    shift
    CONFONLY=1


  elif [ "$1" == "--vh" ]; then
    shift
    BUILDVH=1
  elif [ "$1" == "--VH" ]; then
    shift
    BUILDVH=0





  elif [ "$1" == "--dev" ]; then
    shift
    DEPLOYTYPE=dev

  elif [ "$1" == "--stage" ]; then
    shift
    DEPLOYTYPE=stage

  elif [ "$1" == "--pver" ]; then
    shift
    WOV_PVER="$1"
    shift

  elif [ "$1" == "--sver" ]; then
    shift
    WOV_SVER="$1"
    shift

  elif [ "$1" == "-p" ] || [ "$1" == "--patch" ]; then
    shift
    DEPLOYTYPE=patch
    #doPatchDeployments

  elif [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    fDisplayOptions
    exit 0

  else
    echo
    echo "***ERROR: unknown option '$1'."
    echo
    fDisplayOptions
    exit 1
  fi
done

if [ "$#*" != "0" ]; then
  printf " microservice recipes: $*\n"
else
  printf " microservice recipes: ALL\n"
fi

if [ "${DEPLOYTYPE}" == "" ]; then
  echo ""
  echo "***ERROR deploy needs to specify incremental or full"
  echo "  --dev   [...] : just deploy current dev environment (non-production)"
  echo "  --stage [...] :  deploy versioned system"
  echo "  --patch [...] : patch deployments to point to the STAGE_dev container (--dev does for its own deployments)"
  echo ""

elif [ "${DEPLOYTYPE}" == "dev" ]; then
  doDeployDev $*

elif [ "${DEPLOYTYPE}" == "patch" ]; then
  doPatchDeployments $*

elif [ "${DEPLOYTYPE}" == "stage" ]; then
  doDeployStage $*
fi

