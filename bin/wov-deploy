#!/usr/bin/env bash


# --------------------------------------------------------------------- 
# Import Env 
# --------------------------------------------------------------------- 
if [ ! -z ${WOV_stagemod+x} ]; then
  printf "\nERROR: Can't have WOV_stagemod set when deploying content.\n\n"
  exit 1
fi
deployenvargs=( "$@" )
set ""
. wov-env
. wov-ns-check
set -- "${deployenvargs[@]}"

DOECHO=1
DOFORCE=0
DORETAIN=0
FOLD=$(tput cols)
DRYRUN=0
CONFONLY=0
DEPLOYTYPE=

K8SFILES=
DEPLOYDIR=

# Cache the current values
WOV_CUR_PVER=${WOV_PVER}
WOV_CUR_SVER=${WOV_SVER}



# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doAddLabels()
{
  # --------------------------------------------------------------------- 
  # Add labels
  if [ $DOECHO -ge 1 ]; then echo "  ... labeling namespace"; fi
  R=$(kubectl get namespaces | grep ${WOV_NS})
  if [ "$?" != "0" ]; then
    printf "\n\nERROR: missing namespace '${WOV_NS}'. Type : 'kubectl create namespace ${WOV_NS}' to create one.\n\n"
    exit 1
  fi
  kubectl label namespace ${WOV_NS} --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
}




# --------------------------------------------------------------------- 
# Reads the files and creates ConfigMap and Secrets
#  $1 = ConfigMap file
#  $2 = Secret file
# --------------------------------------------------------------------- 
function doDeployConf()
{
  # Variables for Configmap file
  CMFILE=$1
  if [ "$CMFILE" == "" ]; then
    printf "\nERROR: doDeployConf needs CMFILE defined. Param #1.\n"
    exit 1
  fi

  # Variables for Secrets file
  SEFILE=$2
  if [ "$SEFILE" == "" ]; then
    printf "\nERROR: doDeployConf needs SEFILE defined. Param #2.\n"
    exit 1
  fi

  # Extention to ConfigMap/Secrets entry name (ex. "-local" or "" for nothing)
  FILEEXT=$3

  # Create ConfigMap PLUGIN
  # --------------------------------------------------------------------- 
  #CMFILE=${DEPLOYDIR}/secrets/.cm
  #rm -f ${CMFILE} || true
  #touch ${CMFILE}
  #chmod 600 ${CMFILE}
  #wov-env --cm >> ${CMFILE}
  #USESWOVTOOLS=1 make gen_ck8s > ${CMFILE}
  local f=$(wov-env --var WOV_PROJECT)"$FILEEXT"

  DATA=()
  #DATA+=("--from-literal=WOV_STAGE=${WOV_STAGE}")
  while read l; do
    #echo ":$l"
    d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
    if [ "$d" != "" ]; then DATA+=("$d"); fi
  done <${CMFILE}

  # echo "DATA: ${DATA[@]}"
  kubectl delete configmap ${f} #2> /dev/null
  kubectl create configmap ${f} "${DATA[@]}"
  if [ "$?" != "0" ]; then
    printf "\nERROR: failed creating ConfigMap $f from '${CMFILE}'.\n"
    exit 1
  fi
  # rm -f ${CMFILE}

  # Create Secret PLUGIN
  # --------------------------------------------------------------------- 
  #SEFILE=${DEPLOYDIR}/secrets/.se
  rm -f ${SEFILE} || true
  touch ${SEFILE}
  chmod 600 ${SEFILE}
  #USESWOVTOOLS=1 make gen_sk8s > ${SEFILE}
  wov-env --se > ${SEFILE}

  DATA=()
  while read l; do
    #echo ":$l"
    d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
    if [ "$d" != "" ]; then DATA+=("$d"); fi
  done <${SEFILE}

  kubectl delete secret ${f} #2> /dev/null
  kubectl create secret generic ${f} "${DATA[@]}"
  kubectl label  secret ${f} --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
  if [ "$?" != "0" ]; then
    printf "\nERROR: failed creating Secret $f from '${SEFILE}'.\n"
    exit 1
  fi
  # rm -f ${SEFILE}
}

# --------------------------------------------------------------------- 
# NOTE: this function read in conf/* files to generate ConfigMaps and 
#       Secrets, but those files no longer exist.
# --------------------------------------------------------------------- 
function doDeployConf_old()
{
  # --------------------------------------------------------------------- 
  # Deploy the conf ConfigMap files
  FILES=$(cd ${DEPLOYDIR}/conf; ls *.ck8s 2> /dev/null)
  for F in ${FILES}; do
    f=${F%.ck8s}
    if [ $DOECHO -ge 1 ]; then echo "  ... creating ConfigMap ${f} from ${F}"; fi

    #DATA=$(awk 'NF { print }' ${DEPLOYDIR}/conf/${F} | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "    --from-literal=" $0 }' | gsed ':a;N;$!ba;s/\n/ /g')
    DATA=()
    while read l; do
      #echo ":$l"
      d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
      if [ "$d" != "" ]; then DATA+=("$d"); fi
    done <${DEPLOYDIR}/conf/${F}

    kubectl delete configmap ${f} #2> /dev/null
    kubectl create configmap ${f} "${DATA[@]}"
    if [ "$?" != "0" ]; then
      printf "\nERROR: failed creating ConfigMap $f.\n"
      printf " - check file ${DEPLOYDIR}/conf/${F}\n"
      exit 1
    fi
    kubectl label  configmap ${f} --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
  done

  # --------------------------------------------------------------------- 
  # Deploy the conf secret files
  FILES=$(cd ${DEPLOYDIR}/conf; ls *.sk8s 2> /dev/null)
  for F in ${FILES}; do
    f=${F%.sk8s}
    if [ $DOECHO -ge 1 ]; then echo "  ... creating Secret ${f} from ${F}"; fi
    #  DATA=$(awk 'NF { print }' ${DEPLOYDIR}/conf/${F} | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "    --from-literal=" $0 , "\\" }')
    #DATA=$(awk 'NF { print }' ${DEPLOYDIR}/conf/${F} | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "    --from-literal=" $0 }' | gsed ':a;N;$!ba;s/\n/ /g')
    DATA=()
    while read l; do
      #echo ":$l"
      d=$(echo $l | awk 'NF { print }' | awk -F'=' '!/^($$|[[:blank:]]*#)/ { print "--from-literal=" $0 }' )
      if [ "$d" != "" ]; then DATA+=("$d"); fi
    done <${DEPLOYDIR}/conf/${F}
    kubectl delete secret ${f} #2> /dev/null
    kubectl create secret generic ${f} "${DATA[@]}"
    kubectl label  secret ${f} --overwrite WOV_DEPLOYED=`date +%s` WOV_PVER=${WOV_PVER} WOV_SVER=${WOV_SVER}
  done
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doDeployK8s()
{
  # --------------------------------------------------------------------- 
  # Deploy the k8s files
  if [ $DOECHO -ge 1 ]; then echo "... deploying Kubernetes"; fi
  if [ $DOECHO -ge 2 ]; then echo "  ... from ${DEPLOYDIR}/k8s"; fi

  if [ "$#" != "0" ]; then
    K8SFILES=( $* )
  else
    K8SFILES=( $(cd ${DEPLOYDIR}/k8s/ && ls * | sed -e 's/\(.*\)\..*/\1/') )
  fi

  # printf "K8S FILES: ${K8SFILES[*]}"

  for f in "${K8SFILES[@]}"; do
    if [ ! -e ${DEPLOYDIR}/k8s/$f.yaml ]; then
      printf "ERROR: unknown k8s file '$f.yaml'.\n"

    # NOTE: using ^ and $ for exact match of string
    elif [ "$(jq '.nodeploy[] | test("'"^${f}$"'")' ${WOV_BASEDIR}/wovtools/config.json)" == "true" ]; then
      printf "...skipping '$f': as it is on the nodeploy list in wovtools/config.json\n"
    else
      kubectl apply -f ${DEPLOYDIR}/k8s/$f.yaml
    fi
  done
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doCleanUp()
{
  # --------------------------------------------------------------------- 
  # Cleanup
  if [ ${DORETAIN} == 1 ]; then
    echo "... skipping cleanup"
  else
    rm -Rf ${DEPLOYDIR}
  fi

}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function fDisplayOptions()
{ 
  cat <<EOF | fold -w ${FOLD} -s


usage: `basename $0` [options] {files ...}

Deploys a running kubernetes project from an archive.

files : all by default, or type them here and do individual only

 Deploy Types (one required):
  --dev   : Push current development environment to cluster. 
  --stage : Proper call to roll a version to a stage in the cluster

 Deploy Options:
  --pver|--sver X : sets the Project and Secret version for roll-backs
  -f : force push

 Utility:
  --conf-only : Only push configuration files (ConfigMaps and Secrets)
  --dry-run : pull files but don't deploy
  -r|--retain : retains the deployment values locally (potential security risk)
  -h : this help
  -q/-v : quiet/verbose


EOF
}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
printf "\n"
figlet wov-deploy
printf " version: ${WOV_STAGE}_${WOV_CUR_PVER}_${WOV_CUR_SVER}\n"


if [ "${WOV_STAGE}" == "prod" ]; then
  printf "\n\n**** deploying to production *********************************\n\n"
  printf "   Are you sure? (yes|NO) "
  read A
  if [ "$A" == "yes" ] || [ "$A" == "YES" ]; then
    printf "  ... ok, continuing.\n"
  else
    printf "\n  ... stopping.\n"
    exit 1
  fi
fi


# ---------------------------------------------------------------------
# Push current development environment to cluster. 
# ---------------------------------------------------------------------
function doDeployDev()
{
  if [ ${WOV_STAGE} == 'prod' ]; then
    printf "\n\n\nERROR: deploying straight into production is not allowed. Do a 'wov-push' and then a 'wov-deploy --stage'.\n\n"
    exit 1
  fi

  DEPLOYDIR=${WOV_BASEDIR}/wovtools/cache
  printf " pver : ${WOV_PVER}   sver: ${WOV_SVER}: DEV DEPLOY\n"
  local CMFILE=${DEPLOYDIR}/secrets/.cm
  local SEFILE=${DEPLOYDIR}/secrets/.se
  local CMFILEVH=${DEPLOYDIR}/secrets/.cm-vh
  local SEFILEVH=${DEPLOYDIR}/secrets/.se-vh

  # Capture current wovmod, so can put back later
  local CURWOVMOD=$(wov-mod --get-on)

  # Build standard config files
  {
    wov-mod -q --off ALL

    # Create CM File to read in
    rm -f ${CMFILE} || true
    touch ${CMFILE}
    chmod 600 ${CMFILE}
    wov-env --cm >> ${CMFILE}

    # Create SE File to read in
    rm -f ${SEFILE} || true
    touch ${SEFILE}
    chmod 600 ${SEFILE}
    wov-env --se >> ${SEFILE}
  }

  # Build vh config files
  {
    wov-mod -q --on vh

    # Create CM File to read in
    rm -f ${CMFILEVH} || true
    touch ${CMFILEVH}
    chmod 600 ${CMFILEVH}
    wov-env --cm >> ${CMFILEVH}

    # Create SE File to read in
    rm -f ${SEFILEVH} || true
    touch ${SEFILEVH}
    chmod 600 ${SEFILEVH}
    wov-env --se >> ${SEFILEVH}
  }

  # Return wov-mod status
  wov-mod -q --off ALL ${CURWOVMODS}

  if [ "${CONFONLY}" == "1" ]; then
    doDeployConf "${CMFILE}" "${SEFILE}"
    doDeployConf "${CMFILEVH}" "${SEFILEVH}" "vh"
  else
    k8ses=( $* )
    doAddLabels
    doDeployConf "${CMFILE}" "${SEFILE}"
    doDeployConf "${CMFILEVH}" "${SEFILEVH}" "vh"
    doDeployK8s $k8ses
    # doCleanUp // no cleanup in devdeploy
  fi

  # remove these
  rm -f ${CMFILE} || true
  rm -f ${SEFILE} || true
  rm -f ${CMFILEVH} || true
  rm -f ${SEFILEVH} || true

}


# ---------------------------------------------------------------------
# Proper roll to stage call
# ---------------------------------------------------------------------
function doDeployStage()
{
  # Little more feedback
  if [ "${WOV_CUR_PVER}" != "${WOV_PVER}" ] || [ "${WOV_CUR_SVER}" != "${WOV_SVER}" ]; then
    printf " deploying version: ${WOV_STAGE}_${WOV_PVER}_${WOV_SVER}\n"
  fi
  printf "\n"

  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"


  # If deploying the latest PVER, check that all code is pushed to archive
  if [ "${WOV_CUR_PVER}" == "${WOV_PVER}" ]; then
    wov-git-check ${WOV_BASEDIR}
    R1=$?
    wov-git-check ${WOV_BASEDIR}/wovtools/secrets
    R2=$?
    if [ "$R1" != "0" ] || [ "$R2" != "0" ]; then exit 1; fi
  fi
  #printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"

  # If deploying the latest SVER, check that all env is pushed to archive
  if [ "${WOV_CUR_SVER}" == "${WOV_SVER}" ]; then
    #  deployenvargs=( "$@" )
    #  set ""
    #  . wov-push-env -q
    #  set -- "${deployenvargs[@]}"
    wov-push-env -q
  fi

  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"

  ARCHBASE=${WOV_PROJECT}/${WOV_STAGE}/${WOV_PVER}_${WOV_SVER}

  printf "  ... ARCHBASE : ${ARCHBASE}"

  # --------------------------------------------------------------------- 
  # Make directory to put files
  DEPLOYDIR=${WOV_BASEDIR}/wovtools/cache/.deployments/${WOV_PVER}_${WOV_STAGE}_${WOV_SVER}.$$
  mkdir -p ${DEPLOYDIR}/conf
  mkdir -p ${DEPLOYDIR}/k8s
  chmod -R 700 ${DEPLOYDIR}


  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"

  # --------------------------------------------------------------------- 
  # Pull env files
  aws s3 sync ${WOV_ARCHIVEENV}/${ARCHBASE}/conf ${DEPLOYDIR}/conf  --delete
  aws s3 sync ${WOV_ARCHIVEENV}/${ARCHBASE}/k8s ${DEPLOYDIR}/k8s  --delete

  # printf " check : pver : ${WOV_PVER}   sver: ${WOV_SVER}\n"
  local CMFILE=${DEPLOYDIR}/conf/cm
  local SEFILE=${DEPLOYDIR}/conf/se

  if [ ! -f "$CMFILE" ]; then 
    printf "\nERROR: K8s ConfigMap file does not exist at : '${CMFILE}'.\n"
    exit 1
  fi
  if [ ! -f "$SEFILE" ]; then 
    printf "\nERROR: K8s Secret file does not exist at : '${SEFILE}'.\n"
    exit 1
  fi

  if [ "${DRYRUN}" == "0" ]; then 
    if [ "${CONFONLY}" == "1" ]; then
      doDeployConf "${CMFILE}" "${SEFILE}"
    else
      k8ses=( $* )
      doAddLabels
      doDeployConf "${CMFILE}" "${SEFILE}"
      doDeployK8s $k8ses
      doCleanUp
    fi
  fi

}


# ---------------------------------------------------------------------
# Handle Params
# ---------------------------------------------------------------------
while [[ $1 =~ ^- ]]; do

  if [ "$1" == "-q" ]; then
    shift
    DOECHO=0

  elif [ "$1" == "-v" ]; then
    shift
    DOECHO=2

  elif [ "$1" == "-f" ]; then
    shift
    DOFORCE=1

  elif [ "$1" == "-r" ] || [ "$1" == "--retain" ]; then
    shift
    DORETAIN=1

  elif [ "$1" == "--dry-run" ]; then
    shift
    DRYRUN=1

  elif [ "$1" == "--conf-only" ]; then
    shift
    CONFONLY=1


  elif [ "$1" == "--dev" ]; then
    shift
    DEPLOYTYPE=dev

  elif [ "$1" == "--stage" ]; then
    shift
    DEPLOYTYPE=stage

  elif [ "$1" == "--pver" ]; then
    shift
    WOV_PVER="$1"
    shift

  elif [ "$1" == "--sver" ]; then
    shift
    WOV_SVER="$1"
    shift

  elif [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    fDisplayOptions
    exit 0

  else
    echo
    echo "***ERROR: unknown option '$1'."
    echo
    fDisplayOptions
    exit 1
  fi
done


if [ "${DEPLOYTYPE}" == "" ]; then
  echo ""
  echo "***ERROR deploy needs to specify incremental or full"
  echo "  --dev   : just deploy current dev environment (non-production)"
  echo "  --stage : deploy versioned system"
  echo ""

elif [ "${DEPLOYTYPE}" == "dev" ]; then
  doDeployDev $*

elif [ "${DEPLOYTYPE}" == "stage" ]; then
  doDeployStage $*

fi

