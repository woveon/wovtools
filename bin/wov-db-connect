#!/usr/bin/env bash


# ---------------------------------------------------------------------
# Import Env
# ---------------------------------------------------------------------
wov-env-build -q --local
pushdbenvargs=( "$@" )
set ""
. <(wov-env --exports -e)
. wov-env-common
. wov-db-common
set -- "${pushdbenvargs[@]}"

DOECHO=1
FOLD=$(tput cols)
DATABASESERVER=
DB_COMMAND=
DB_OP=
DB_FILE=

DB_HEADEROPTIONS=
DATASETFILES=( 'schema' 'data' 'clear' )



# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function fDisplayOptions()
{
  cat <<EOF | fold -w ${FOLD} -s


usage: `basename $0` DBSERVER {options}

Connect to a database server via SSH tunnelling through the bastion host. Takes information from Woveon environment variables. The default command is (-c) to open a shell.

DBSERVER - the name of a database server in the project (created via wov-cluster-createdb).

  -h : this help
  -q/-v : quiet/verbose

 Database Commands:
  -c [command]  : run a DB command
  -f [file]     : load file of SQL commands into a DB
  --schema      : return the DB's schema
  --info        : reports about the database

 Data Mods:
  -d [database] : changes the database name (DB inside the DB server)
  -U [user]     : DB user
  -p            : prompt for a password

 DataSets : non-production data management:
  -ldbs               : list all DataSets
  --data-schema/-ds X : with DataSet X, reloads the database schema (clearing existing data)
  --data-clear/-dc  X : with DataSet X, clears data in the database
  --data-data/-dd   X : with DataSet X, loads the database data
  --data-reload/-dr X : with DataSet X, reloads the database data (clear and data)
  --data-full/-df   X : with DataSet X, loads a full DataSet by loading schema, clear and load data

 Local Postgres via Docker:
  --docker-postgres-start : start a local Postgres database via Docker
  --docker-postgres-stop  : stop a local Postgres database in Docker

 DB Management: (note: change namespace or turn off local to change databases)
  -ldb         : list all databases
  --db-init    : initialize the database for WovTools
  --db-ver     : returns the current 
  --db-log     : returns the log of commits for the database
  --db-wait    : wait for a database to come online after creation

NOTE:
About commands (-c)... you have to be careful about quotes as both bash and psql are very particular. Here, use single quotes so '*' is not expanded, and quote the single quote so mydatabase is interpret properly by postgres.

ex. -c 'SELECT * FROM logs WHERE database=\'mydatabase\' ORDER BY id DESC LIMIT 1'

EOF
}

# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function doDBList()
{
  local DATABASES=( $(doFindDatabases) )
  echo "${DATABASES[@]}"
}

# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function doDBListSet()
{
#  local S=$(IFS=, ; echo "${DATASETFILES[*]}")

  local fname=()
  local fname2=()

  # find files
  for s in ${DATASETFILES[@]}; do
    fname+=( $(cd ${WOV_BASEDIR}/wovtools/data ; ls -- *_$s.sql* ) )
  done
#  echo "fname: '${fname[@]}'"

  # find roots
  for f in ${fname[@]}; do
    local F=( ${f//_/ } )
    fname2+=( "${F[0]}" )
  done
#  echo "fname2: '${fname2[@]}'"

  # uniq them
  local fnamen=( $(echo "${fname2[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ') )
  echo "${fnamen[@]}"
}

# Help command catch here
if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then fDisplayOptions; exit 0; fi
if [ "$1" == "-ldb" ]; then doDBList; exit 0; fi
if [ "$1" == "-ldbs" ]; then doDBListSet; exit 0; fi


# Set the default commands
if [ "$#" == "0" ] && [ "$WOV_PROJECTTYPE" != "pl" ] ; then
  printf "\n\nERROR: need to provide the name of the database server.\n"
  sleep .8
  fDisplayOptions
  exit 1
fi
DATABASESERVER=$1
shift


# --------------------------------------------------------------------- 
# Set config from env vars and project type
# --------------------------------------------------------------------- 
doSetDBData()
{
  DB_SUBHOST=WOV_${DATABASESERVER}_subhost
  DB_TYPE=WOV_${DATABASESERVER}_type
  DB_DATABASE=WOV_${DATABASESERVER}_database
  DB_USERNAME=WOV_${DATABASESERVER}_username
  DB_PASSWORD=WOV_${DATABASESERVER}_password
#  DB_HOST=WOV_${DATABASESERVER}_host
  DB_HOST=localhost
  DB_PORT=WOV_${DATABASESERVER}_port
  DB_INSTANCEAVAILABILITYZONE=WOV_${DATABASESERVER}_instanceAvailabilityZone
  DB_INSTANCEAVAILABILITYZONEALT=WOV_${DATABASESERVER}_instanceAvailabilityZoneAlt
  DB_INSTANCE_CLASS=WOV_${DATABASESERVER}_instance_class
  DB_INSTANCE_STORAGE=WOV_${DATABASESERVER}_instance_storage
  DB_VERSION=WOV_${DATABASESERVER}_version

  DB_HEADEROPTIONS=-t

  ## if in Plugin and using default database, default to the mongodb
  #if [[ ( "$DATABASESERVER" == "" ) || ( "$DATABASESERVER" == "${WOV_PROJECT}db" ) ]] && [[ "${WOV_PROJECTTYPE}" == "pl" ]]; then
  #  # echo "...defaulting to plugin mongodb."
  #  DB_TYPE=WOV_we_db_type
  #  DB_DATABASE=WOV_we_db_collection
  #  DB_USERNAME=WOV_we_db_user
  #  DB_PASSWORD=WOV_we_db_password
  #  DB_HOST=WOV_we_db_url
  #  DB_PORT=WOV_we_db_port
  #  DATABASESERVER=${WOV_PROJECT}db
  #fi

  # Set variables to values of the name
  DB_SUBHOST=${!DB_SUBHOST}
  DB_TYPE=${!DB_TYPE}
  DB_DATABASE=${!DB_DATABASE}
  DB_USERNAME=${!DB_USERNAME}
  DB_PASSWORD=${!DB_PASSWORD}
#  DB_HOST=${!DB_HOST}
  DB_PORT=${!DB_PORT}
  DB_INSTANCEAVAILABILITYZONE=${!DB_INSTANCEAVAILABILITYZONE}
  DB_INSTANCEAVAILABILITYZONEALT=${!DB_INSTANCEAVAILABILITYZONEALT}
  DB_INSTANCE_CLASS=${!DB_INSTANCE_CLASS}
  DB_INSTANCE_STORAGE=${!DB_INSTANCE_STORAGE}
  DB_VERSION=${!DB_VERSION}
}

# 1st call
doSetDBData


# NOTE: using bastion so this overrides cluster settings
#DB_PORT=$(wov-bastion --bhost ${WOV_CLUSTER}-bastion --ldp ${DATABASESERVER})
#DB_HOST=localhost   # bastion

# --------------------------------------------------------------------- 
# Builds the X data set for a database from the wovtools/data/X_* files
#  $1 - data set name (ex. alywan)
# --------------------------------------------------------------------- 
function doDBDataBuild()
{
  if [ "$1" == "" ]; then echo "ERROR: need a data set name parameter to wov-db-connect::doDBDataBuild."; exit 1; fi


  # Make the target directory
  mkdir -m 700 -p ${WOV_BASEDIR}/wovtools/cache/data
  if [ $? -ne 0 ]; then echo "ERROR: failed to make target data directory in cache."; exit 1; fi

  for f in ${DATASETFILES[@]}; do

    local fname=`cd ${WOV_BASEDIR}/wovtools/data ; ls $1_$f.*`
    # echo "f: '${f}'  fname: '${fname}'   last 4: '${fname: -4}'"

    # compile file if it has .wov on it
    if [ "${fname: -4}" == ".wov" ]; then
      local finname="${fname::-4}"
      if [ ! -e "${WOV_BASEDIR}/wovtools/cache/data/${finname}" ] ||
         [ "${WOV_BASEDIR}/wovtools/data/${1}_const.js" -nt "${WOV_BASEDIR}/wovtools/cache/data/${finname}" ] ||
         [ "${WOV_BASEDIR}/wovtools/data/${fname}" -nt "${WOV_BASEDIR}/wovtools/cache/data/${finname}" ]; then
        if [ ${DOECHO} -ge 1 ]; then echo "  ... compile ${finname}"; fi
        WOV_BASEDIR=${WOV_BASEDIR} wov-compile -ds ${1} "${WOV_BASEDIR}/wovtools/cache/clusters/${WOV_CLUSTER}/secrets.json" "${WOV_BASEDIR}/wovtools/data/${fname}" > "${WOV_BASEDIR}/wovtools/cache/data/${finname}"
      fi

    # or copy it over
    else
      if [ ! -e "${WOV_BASEDIR}/wovtools/cache/data/${fname}" ]; then
        if [ ${DOECHO} -ge 1 ]; then echo "  ... cp ${fname}"; fi
        cp "${WOV_BASEDIR}/wovtools/data/${fname}" "${WOV_BASEDIR}/wovtools/cache/data/."
      fi
    fi

  done
}


# --------------------------------------------------------------------- 
# Loads a data set file.
# $1 - data set to use
# #2 - data command to run: schema, clear or data which match to a file 
# --------------------------------------------------------------------- 
function doDBDataCommand()
{
  if [ "$WOV_STAGE" == "prod" ]; then echo "ERROR: wov-db-connect DataSets do not work on production."; exit 1; fi
  if [ "$1" == "" ]; then echo "ERROR: need a data set name parameter to wov-db-connect::doDBDataCommand."; exit 1; fi
  if [ "$2" == "schema" ] ||
     [ "$2" == "clear" ] ||
     [ "$2" == "data" ]; then
    local A=1
  else
    echo "ERROR: Unknown command for doDBDataCommand of '${2}'. Should be one of 'schema', 'clear', or 'data'."
    exit 1
  fi

  R=$(PGPASSWORD=${DB_PASSWORD} psql --quiet -P "footer=off" -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f "${WOV_BASEDIR}/wovtools/cache/data/${1}_${2}.sql") ; Re=$?
  if [ ${DOECHO} -ge 2 ]; then echo "${R}"; fi
  if [ ${DOECHO} -ge 1 ]; then echo "  ... loaded ${1}_${2}.sql"; fi
  if [ "$Re" != "0" ]; then
    printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
    exit 1
  fi
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function doDatabaseConnectMessage()
{
  printf "\n\n"
  figlet "${WOV_NS}"
  printf "  DBServer : ${DATABASESERVER}\n"
  printf "  Type     : ${DB_TYPE}\n"
  printf "  User     : ${DB_USERNAME}\n"
  printf "  Host     : ${DB_HOST}\n"
  printf "  Port     : ${DB_PORT}\n"
  printf "  Database : ${DB_DATABASE}\n\n"
}


# --------------------------------------------------------------------- 
# --------------------------------------------------------------------- 
function setAsAdmin()
{
  DB_USERNAME="$(wov-env --var WOV_${DATABASESERVER}_admin_username)"
  DB_PASSWORD="$(wov-env --var WOV_${DATABASESERVER}_admin_password)"
  if [ "${DB_USERNAME}" == "" ] || [ "${DB_PASSWORD}" == "" ]; then
    printf "\n\nERROR: Setting as admin, but you have no admin configured. Ensure WOV_${DATABASESERVER}_admin_[username/password] is configured in your secrets.\n\n"
    exit 1
  fi
}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function doDBInit()
{
  mkdir -p ${WOV_BASEDIR}/wovtools/db/archive

  # Create 'wovtools' database in db server if it does not exist
  export PGPASSWORD=${DB_PASSWORD}
  psql -h localhost -U ${DB_USERNAME} -tc "SELECT 1 FROM pg_database WHERE datname = 'wovtools'" | grep -q 1 || psql -U ${DB_USERNAME} -h localhost -c "CREATE DATABASE wovtools"

  # in 'wovtools', create the logs table, and insert a row
  psql -U ${DB_USERNAME} -h localhost -d wovtools -tc "CREATE TABLE IF NOT EXISTS logs (id SERIAL NOT NULL PRIMARY KEY, database varchar, wovtoolsver varchar, label varchar, pver integer, sver integer, snapshot varchar, schema varchar DEFAULT NULL, created_at TIMESTAMPTZ NOT NULL DEFAULT NOW() );"

  # first delta is that it exists
  cat <<EOF >> ${WOV_BASEDIR}/wovtools/db/${DATABASESERVER}.deltas
# ---------------------------------------------------------------------
# doInitDB called for: ${DATABASESERVER}
# ---------------------------------------------------------------------
# 1) create wovtools database if not exist
# 2) create the logs database in wovtools
# ---------------------------------------------------------------------
EOF

  # Init the archive for it
  if [ ! -e "${WOV_BASEDIR}/wovtools/db/archive/${DATABASESERVER}.json" ]; then
    cat <<EOF >> ${WOV_BASEDIR}/wovtools/db/archive/${DATABASESERVER}.json
{
  "wovtoolsversion": "0",
  "versions": {}
}
EOF
  fi

}


# ---------------------------------------------------------------------
# returns 0 on success
# ---------------------------------------------------------------------
function doDBGetVer()
{
  local retval=1

  R=$(PGPASSWORD=${DB_PASSWORD} psql -h localhost -d wovtools -U ${DB_USERNAME} --tuples-only -c "SELECT * from logs order by id DESC limit 1;" 2> /dev/null ) ; Re=$?
  if [ ${Re} == "0" ] ; then
    if [ "${R}" == "" ]; then echo "None"; 
    else 
      echo "${R}" | cut -d'|' -f5 | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
    fi
    retval=0
  else
    echo "Uninited"
  fi

  return $retval
}


# ---------------------------------------------------------------------
# returns 0 on success
# ---------------------------------------------------------------------
function doDBGetLog()
{
  local retval=1

  R=$(PGPASSWORD=${DB_PASSWORD} psql -h localhost -d wovtools -U ${DB_USERNAME} --tuples-only -c "SELECT * from logs order by id DESC;" 2> /dev/null ) ; Re=$?
  if [ ${Re} == "0" ] ; then
    if [ "${R}" == "" ]; then echo "None"; 
    else echo $R; fi
    retval=0
  else
    echo "Uninited"
  fi

  return $retval
}


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function doInfo()
{
#  . <(wov-env -c wov-aws-va-grape --exports)
#  doSetDBData

  cat <<EOF

DB Information
---------------------------------------------------------------------
  AWS Server : $(doResName DB ${WOV_CLUSTER} ${DB_SUBHOST}):${DB_PORT}
    Database : ${DB_DATABASE}  User: ${DB_USERNAME} PASSWORDXXX
        Type : ${DB_TYPE} ${DB_VERSION}, ${DB_INSTANCE_STORAGE} GB, ${DB_INSTANCE_CLASS}, zones: ${AWS_REGION}${DB_INSTANCEAVAILABILITYZONE} ${AWS_REGION}${DB_INSTANCEAVAILABILITYZONEALT}

  WovTools Version: $(doDBGetVer)
  
EOF
}


# ---------------------------------------------------------------------
# Wait for db to get address, meaning it is ready to go
# $1=[dbname]
# ---------------------------------------------------------------------
function doDBWait()
{

  if [ "$1" == "localhost" ]; then
    echo "ERROR: asking to wait for localhost database. Turn off local database in config/local.json secretsmods.local."
    exit 1
  fi

  # check for existence
  S=$(aws rds describe-db-instances --db-instance-identifier $(doResName DB ${WOV_CLUSTER} ${1}) --query 'DBInstances[0].Endpoint.Address' --output text) ; Se=$?
  if [ $Se == 255 ]; then echo "ERROR: unknown database."; exit 1; fi


  # wait for it to get an address
  while [ "$(aws rds describe-db-instances --db-instance-identifier $(doResName DB ${WOV_CLUSTER} ${1}) --query 'DBInstances[0].Endpoint.Address' --output text)" == "None" ]; do
    echo "    ... waiting for database to get address."
    sleep 5
  done

  # wait for it to be available
  while [ "$(aws rds describe-db-instances --db-instance-identifier $(doResName DB ${WOV_CLUSTER} ${1}) --query 'DBInstances[0].DBInstanceStatus' --output text)" != "available" ]; do
    echo "    ... waiting for database to come online."
    sleep 5
  done
}




# ---------------------------------------------------------------------
# Handle Params
# ---------------------------------------------------------------------
while [[ $1 =~ ^- ]]; do

  if [ "$1" == "-q" ]; then
    shift
    DOECHO=0

  elif [ "$1" == "-v" ]; then
    shift
    DOECHO=2

  elif [ "$1" == "-p" ]; then
    shift
    read DB_PASSWORD
    shift

  elif [ "$1" == "--info" ]; then
    doInfo
    exit 0

  elif [ "$1" == "--admin" ]; then
    shift
    setAsAdmin

#  elif [ "$1" == "-n" ] || [ "$1" == "--namespace" ]; then
#    shift
#    NAMESPACE="${1}"
#    shift

  elif [ "$1" == "-U" ]; then
    shift
    DB_USERNAME="$1"
    shift

  elif [ "$1" == "-d" ]; then
    shift
    DB_DATABASE="$1"
    shift

  elif [ "$1" == "-f" ]; then
    shift
    DB_OP="file"
    DB_FILE="$1"
    shift

  elif [ "$1" == "--headers" ]; then
    shift
    DB_HEADEROPTIONS=

  elif [ "$1" == "--noheaders" ]; then
    shift
    DB_HEADEROPTIONS=-t

  elif [ "$1" == "-c" ]; then
    shift
    DB_OP="command"
    DB_COMMAND="$1" # ( $1 )
    #DB_COMMAND2=( $1 )
    #echo "DB_COMMAND1 : '${DB_COMMAND}'"
    #echo "DB_COMMAND2 : '${DB_COMMAND2[*]}'"
    shift

  elif [ "$1" == "--schema" ]; then
    shift
    DB_OP="schema"

  elif [ "$1" == "--data-schema" ] || [ "$1" == "-ds" ]; then
    shift
    doDBDataBuild $1
    doDBDataCommand $1 "schema"
    exit 0
    shift

  elif [ "$1" == "--data-clear" ] || [ "$1" == "-dc" ]; then
    shift
    doDBDataBuild $1
    doDBDataCommand $1 "clear"
    exit 0
    shift

  elif [ "$1" == "--data-data" ] || [ "$1" == "-dd" ]; then
    shift
    doDBDataBuild $1
    doDBDataCommand $1 "data"
    exit 0
    shift

  elif [ "$1" == "--data-reload" ] || [ "$1" == "-dr" ]; then
    shift
    doDBDataBuild $1
    doDBDataCommand $1 'clear'
    doDBDataCommand $1 'data'
    exit 0
    shift

  elif [ "$1" == "--data-full" ] || [ "$1" == "-df" ]; then
    shift
    doDBDataBuild $1
    doDBDataCommand $1 'schema'
    doDBDataCommand $1 'clear'
    doDBDataCommand $1 'data'
    exit 0
    shift

  elif [ "$1" == "--docker-postgres-start" ]; then
    shift
    pg_isready -p 5432 -h localhost 2>&1  > /dev/null
    A=$?
    if [ "$A" == "0" ]; then echo "ERROR: postgres already accepting connections. Try --docker-postgres-stop."; exit 1; fi

    # match major/minor versions
    pgsplit=( $(echo $DB_VERSION | tr "." "\n") )
    pgmajorminor="${pgsplit[0]}.${pgsplit[1]}"

    docker run --rm --name postgres-local -e POSTGRES_PASSWORD=${DB_PASSWORD} -d -p 5432:5432 "postgres:${pgmajorminor}"
    I=0
    while [ "$(pg_isready -p 5432 -h localhost 2>&1 > /dev/null ; echo $?)" != "0" ]; do
      sleep 1 # sleep to account for time for it to spin up
      I=$((I + 1))
      if [ $I -gt 10 ]; then echo "ERROR: failed to connect to local postgres." ; exit 1; fi
    done
    PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -c "create database ${DB_DATABASE}"  > /dev/null
    if [ "$?" != "0" ]; then echo "ERROR: could not create database of '${DB_DATABASE}'."; exit 1; fi
    echo "  ... success"
    exit 0

  elif [ "$1" == "--docker-postgres-stop" ]; then
    shift
    docker stop postgres-local > /dev/null
    if [ "$?" == "0" ]; then echo "  ... success"; exit 0; fi
    exit 0

  elif [ "$1" == "--db-init" ]; then
    shift
    doDBInit
    exit 0

  elif [ "$1" == "--db-ver" ]; then
    shift
    doDBGetVer
    exit 0

  elif [ "$1" == "--db-log" ]; then
    shift
    doDBGetLog
    exit 0

  elif [ "$1" == "--db-wait" ]; then
    shift
    doDBWait ${DB_SUBHOST}
    exit 0

  elif [ "$1" == "-ldb" ]; then
    shift
    doDBList
    exit 0

  elif [ "$1" == "-ldbs" ]; then
    shift
    doDBListSet
    exit 0

  elif [ "$1" == "-H" ]; then
    shift
    DB_HOST="$1"
    shift

  elif [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    fDisplayOptions
    exit 0

  else
    echo
    echo "***ERROR: unknown option '$1'."
    echo
    fDisplayOptions
    exit 1
  fi
done



#if [ $DOECHO -ge 1 ]; then echo "... connecting to ${DATABASESERVER} (${DB_HOST}) via vh (user ${DB_USERNAME} on ${DB_DATABASE})"; fi


# Check vh pod exists
# wov-p vh >/dev/null
#kubectl get pods vh > /dev/null
#if [ "$?" == "1" ]; then
#  printf "\n\nERROR: 'vh' has not been created. Run 'wov-vh -s'.\n\n"
#  exit 1
#fi

if [ "${DB_TYPE}" == "postgres" ]; then

  if [ "${DB_OP}" == "schema" ]; then
    # Log into pod 'vh', run pg_dump
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} pg_dump -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -s"
#    else
#      PGPASSWORD=${DB_PASSWORD} pg_dump -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -s
#    fi

    PGPASSWORD="${DB_PASSWORD}" pg_dump -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -s
    if [ "$?" != "0" ]; then
      printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
      exit 1
    fi

  elif [ "${DB_OP}" == "command" ]; then
    # Log into pod 'vh', run psql
#    echo "dbcommand  : \"${DB_COMMAND}\""
#    echo "dbcommand q: \"${DB_COMMAND[@]}\""
#    VARS=( "PGPASSWORD=${DB_PASSWORD}" "psql" "--tuples-only" "-h" "${DB_HOST}" "-U" "${DB_USERNAME}" "-d" "${DB_DATABASE}" "-c" "${DB_COMMAND}" )
#    kubectl exec -i vh -- /bin/bash -c "${VARS[@]}"
#    kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql --tuples-only -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c ${DB_COMMAND}"
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql --tuples-only -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c \"${DB_COMMAND[@]}\""
#    else
#      PGPASSWORD=${DB_PASSWORD} psql --tuples-only -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c \"${DB_COMMAND[@]}\"
#    fi

    R=$(PGPASSWORD="${DB_PASSWORD}" psql ${DB_HEADEROPTIONS} -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c "${DB_COMMAND[*]}"  2>&1 ) ; Re=$?
    #PGPASSWORD=${DB_PASSWORD} psql --tuples-only -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c "${DB_COMMAND[*]}"
    if [ "${Re}" != "0" ]; then
      if [ "$R" == "psql: FATAL:  database \"wovtools\" does not exist" ]; then
        printf "\n${R}\nERROR: did you init the database? 'wov-db-connect ${DATABASESERVER} --db-init'\n"
        exit 1
      fi
      printf "${R}\n"
      printf "\n\nERROR(${Re}): could not connect... have you tunneled to the bastion server?\n\n"
      exit 1
    fi


  elif [ "${DB_OP}" == "file" ]; then
    # copy file; exectute it in database, delete file
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl cp ${DB_FILE} vh:.${DATABASESERVER}.sql.$$
#      kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f .${DATABASESERVER}.sql.$$"
#      kubectl exec -i vh -- /bin/bash -c "rm -f .${DATABASESERVER}.sql.$$"
#    else
#      PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f ${DB_FILE}
#    fi
    PGPASSWORD="${DB_PASSWORD}" psql -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f ${DB_FILE}
    PGPASSWORDe=$?
    if [ "$PGPASSWORDe" != "0" ]; then
      printf "\n\nERROR(${PGPASSWORDe}): could not connect... have you tunneled to the bastion server?\n\n"
      exit 1
    fi

  elif [ "${DB_OP}" == "" ]; then
    # Log into pod 'vh', run psql
    if [ $DOECHO -ge 1 ]; then doDatabaseConnectMessage; fi
    if [ $DOECHO -ge 2 ]; then echo "... connect with 'PGPASSWORD=... psql -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}'"; fi
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -it vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}"
#    else
#      PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}
#    fi
    PGPASSWORD="${DB_PASSWORD}" psql -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}
    if [ "$?" != "0" ]; then
      printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
      exit 1
    fi
  fi

elif [ "${DB_TYPE}" == "mongo" ]; then


  if [ "${DB_OP}" == "schema" ]; then
    # NOTE: mongo has no schema, so taking from first returned object
    DB_COMMAND=$(cat <<EOF
function printSchema(obj) {
  for (var key in obj) {
    print(' ', key, typeof obj[key]) ;
  }
};
db.getCollectionNames().forEach(function(collname) {
  print('COLLECTION:', collname);
  // printSchema(db[collname].findOne()); // NOTE: not calling since if there is no object, then no schema
})
EOF
)

    kubectl exec -it $(wov-p ${DATABASESERVER}-${WOV_STAGE} ) -- sh -c "mongo --quiet ${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    else
#      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\"
#    fi


  elif [ "${DB_OP}" == "command" ]; then
    kubectl exec -it $(wov-p ${DATABASESERVER}-${WOV_STAGE} ) -- sh -c "mongo --quiet ${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    else
#      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\"
#    fi
  elif [ "${DB_OP}" == "file" ]; then
    printf "\nFile: untested\n\n";
    if [ "${DB_HOST}" != "localhost" ]; then
      kubectl cp ${DB_FILE} vh:.${DATABASESERVER}.sql.$$
      kubectl exec -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} ${DBSERVER}.sql.$$"
      kubectl exec -i vh -- /bin/bash -c "rm -f .${DATABASESERVER}.sql.$$"
    else
      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} ${DB_FILE}
    fi
  elif [ "${DB_OP}" == "" ]; then
    if [ $DOECHO -ge 1 ]; then doDatabaseConnectMessage; fi
    
    echo "entering pod ${DATABASESERVER}-${WOV_STAGE}"
    kubectl exec -it $(wov-p ${DATABASESERVER}-${WOV_STAGE} ) -- sh -c "mongo --quiet ${DB_DATABASE}"
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec  -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE}"
#    else
#      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE}
#    fi

  fi

else
  printf "\n\nERROR: Unknown database type of '${DB_TYPE}'. Probably need to implement it in wov-db-connect, and ensure it is supported in vh container.\n"
  exit 1
fi


