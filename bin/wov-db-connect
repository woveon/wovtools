#!/usr/bin/env bash



# ---------------------------------------------------------------------
# Import Env
# ---------------------------------------------------------------------
wov-build -i -e
pushenvargs=( "$@" )
set ""
. <(wov-env --exports)
#. wov-ns-check
set -- "${pushenvargs[@]}"

DOECHO=1
FOLD=$(tput cols)
DATABASESERVER=
#NAMESPACE="${WOV_NS}"
DB_COMMAND=
DB_OP=
DB_FILE=


# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
function fDisplayOptions()
{
  cat <<EOF | fold -w ${FOLD} -s


usage: `basename $0` [databaseserver] {options}

Connect to a database via vh (virtual host) pod in Kubernetes. Takes information from Woveon environment variables. If no commands are given (-c), then opens a shell.

databaseserver - the name of a database server in the project. assumes conf/[database].[cs]k8s files.

  -d [database] : sets the database inside the server
  -U [user]     : login user
  -f [file]     : load file
  -c [command]  : run command
  -p            : ask for password
  -h : this help
  -q/-v : quiet/verbose

About commands... you have to be careful about quotes as both bash and psql are very particular. Here, use single quotes so '*' is not expanded, and quote the single quote so mydatabase is interpret properly by postgres.

ex. -c 'SELECT * FROM logs WHERE database=\'mydatabase\' ORDER BY id DESC LIMIT 1'

EOF
}

# Set the default commands
if [ "$#" == "0" ] && [ "$WOV_PROJECTTYPE" != "pl" ] ; then
  printf "\n\nERROR: need to provide the name of the database server.\n"
  sleep .8
  fDisplayOptions
  exit 1
fi
if [ "$1" == "-h" ]; then
  fDisplayOptions
  exit 0
fi
DATABASESERVER=$1
shift

#echo $DATABASESERVER

# load env vars
#eval $(wov-env --env ${DATABASESERVER}.ck8s --env ${DATABASESERVER}.sk8s )
#if [ "${WOV_stagemod}" != "" ]; then
#  eval $(wov-env --mod ${WOV_stagemod} --conf)
#else
#  eval $(wov-env --conf)
#fi

# --------------------------------------------------------------------- 
# Set config from env vars and project type
# --------------------------------------------------------------------- 
DB_TYPE=WOV_${DATABASESERVER}_type
DB_DATABASE=WOV_${DATABASESERVER}_database
DB_USERNAME=WOV_${DATABASESERVER}_username
DB_PASSWORD=WOV_${DATABASESERVER}_password
DB_HOST=WOV_${DATABASESERVER}_host
DB_PORT=WOV_${DATABASESERVER}_port

# Plugins use a mongodb
if [ "${WOV_PROJECTTYPE}" == "pl" ]; then
  DB_TYPE=WOV_we_db_type
  DB_DATABASE=WOV_we_db_collection
  DB_USERNAME=WOV_we_db_user
  DB_PASSWORD=WOV_we_db_password
  DB_HOST=WOV_we_db_url
  DB_PORT=WOV_we_db_port
  set -x
  DATABASESERVER=${WOV_PROJECT}db
fi

# Set variables to values of the name
DB_TYPE=${!DB_TYPE}
DB_DATABASE=${!DB_DATABASE}
DB_USERNAME=${!DB_USERNAME}
DB_PASSWORD=${!DB_PASSWORD}
DB_HOST=${!DB_HOST}
DB_PORT=${!DB_PORT}
set +x


# NOTE: using bastion so this overrides cluster settings
#DB_PORT=$(wov-bastion --bhost ${WOV_CLUSTER}-bastion --ldp ${DATABASESERVER})
#DB_HOST=localhost   # bastion

function doDatabaseConnectMessage()
{
  printf "\n\n"
  figlet "${WOV_NS}"
  printf "  DBServer : ${DATABASESERVER}\n"
  printf "  Type     : ${DB_TYPE}\n"
  printf "  User     : ${DB_USERNAME}\n"
  printf "  Host     : ${DB_HOST}\n"
  printf "  Database : ${DB_DATABASE}\n\n"
}

# ---------------------------------------------------------------------
# Handle Params
# ---------------------------------------------------------------------
while [[ $1 =~ ^- ]]; do

  if [ "$1" == "-q" ]; then
    shift
    DOECHO=0

  elif [ "$1" == "-v" ]; then
    shift
    DOECHO=2

  elif [ "$1" == "-p" ]; then
    shift
    read DB_PASSWORD
    shift

#  elif [ "$1" == "-n" ] || [ "$1" == "--namespace" ]; then
#    shift
#    NAMESPACE="${1}"
#    shift

  elif [ "$1" == "-U" ]; then
    shift
    DB_USERNAME="$1"
    shift

  elif [ "$1" == "-d" ]; then
    shift
    DB_DATABASE="$1"
    shift

  elif [ "$1" == "-f" ]; then
    shift
    DB_OP="file"
    DB_FILE="$1"
    shift

  elif [ "$1" == "-c" ]; then
    shift
    DB_OP="command"
    DB_COMMAND="$1" # ( $1 )
    #DB_COMMAND2=( $1 )
    #echo "DB_COMMAND1 : '${DB_COMMAND}'"
    #echo "DB_COMMAND2 : '${DB_COMMAND2[*]}'"
    shift

  elif [ "$1" == "--schema" ]; then
    shift
    DB_OP="schema"

  elif [ "$1" == "-H" ]; then
    shift
    DB_HOST="$1"
    shift

  elif [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    fDisplayOptions
    exit 0

  else
    echo
    echo "***ERROR: unknown option '$1'."
    echo
    fDisplayOptions
    exit 1
  fi
done



#if [ $DOECHO -ge 1 ]; then echo "... connecting to ${DATABASESERVER} (${DB_HOST}) via vh (user ${DB_USERNAME} on ${DB_DATABASE})"; fi


# Check vh pod exists
# wov-p vh >/dev/null
#kubectl get pods vh > /dev/null
#if [ "$?" == "1" ]; then
#  printf "\n\nERROR: 'vh' has not been created. Run 'wov-vh -s'.\n\n"
#  exit 1
#fi

if [ "${DB_TYPE}" == "postgres" ]; then

  if [ "${DB_OP}" == "schema" ]; then
    # Log into pod 'vh', run pg_dump
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} pg_dump -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -s"
#    else
#      PGPASSWORD=${DB_PASSWORD} pg_dump -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -s
#    fi

    PGPASSWORD=${DB_PASSWORD} pg_dump -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -s
    if [ "$?" != "0" ]; then
      printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
    fi

  elif [ "${DB_OP}" == "command" ]; then
    # Log into pod 'vh', run psql
#    echo "dbcommand  : \"${DB_COMMAND}\""
#    echo "dbcommand q: \"${DB_COMMAND[@]}\""
#    VARS=( "PGPASSWORD=${DB_PASSWORD}" "psql" "--tuples-only" "-h" "${DB_HOST}" "-U" "${DB_USERNAME}" "-d" "${DB_DATABASE}" "-c" "${DB_COMMAND}" )
#    kubectl exec -i vh -- /bin/bash -c "${VARS[@]}"
#    kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql --tuples-only -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c ${DB_COMMAND}"
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql --tuples-only -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c \"${DB_COMMAND[@]}\""
#    else
#      PGPASSWORD=${DB_PASSWORD} psql --tuples-only -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c \"${DB_COMMAND[@]}\"
#    fi

    PGPASSWORD=${DB_PASSWORD} psql --tuples-only -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -c "${DB_COMMAND[*]}"
    if [ "$?" != "0" ]; then
      printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
    fi


  elif [ "${DB_OP}" == "file" ]; then
    # copy file; exectute it in database, delete file
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl cp ${DB_FILE} vh:.${DATABASESERVER}.sql.$$
#      kubectl exec -i vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f .${DATABASESERVER}.sql.$$"
#      kubectl exec -i vh -- /bin/bash -c "rm -f .${DATABASESERVER}.sql.$$"
#    else
#      PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f ${DB_FILE}
#    fi
    PGPASSWORD=${DB_PASSWORD} psql -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE} -f ${DB_FILE}
    if [ "$?" != "0" ]; then
      printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
    fi

  elif [ "${DB_OP}" == "" ]; then
    # Log into pod 'vh', run psql
    doDatabaseConnectMessage
    if [ $DOECHO -ge 2 ]; then echo "... connect with 'PGPASSWORD=... psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}'"; fi
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -it vh -- /bin/bash -c "PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}"
#    else
#      PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}
#    fi
set -x
    PGPASSWORD=${DB_PASSWORD} psql -p ${DB_PORT} -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_DATABASE}
set +x
    if [ "$?" != "0" ]; then
      printf "\n\nERROR: could not connect... have you tunneled to the bastion server?\n\n"
    fi
  fi

elif [ "${DB_TYPE}" == "mongo" ]; then

  if [ "${DB_OP}" == "schema" ]; then
    # NOTE: mongo has no schema, so taking from first returned object
    DB_COMMAND=$(cat <<EOF
function printSchema(obj) {
  for (var key in obj) {
    print(' ', key, typeof obj[key]) ;
  }
};
db.getCollectionNames().forEach(function(collname) {
  print('COLLECTION:', collname);
  // printSchema(db[collname].findOne()); // NOTE: not calling since if there is no object, then no schema
})
EOF)

set -x
    kubectl exec -it $(wov-p ${DATABASESERVER}-${WOV_STAGE} ) -- sh -c "mongo --quiet ${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    else
#      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\"
#    fi
set +x


  elif [ "${DB_OP}" == "command" ]; then
    set -x
    kubectl exec -it $(wov-p ${DATABASESERVER}-${WOV_STAGE} ) -- sh -c "mongo --quiet ${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\""
#    else
#      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} --eval \"${DB_COMMAND}\"
#    fi
  elif [ "${DB_OP}" == "file" ]; then
    printf "\nFile: untested\n\n";
    if [ "${DB_HOST}" != "localhost" ]; then
      kubectl cp ${DB_FILE} vh:.${DATABASESERVER}.sql.$$
      kubectl exec -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} ${DBSERVER}.sql.$$"
      kubectl exec -i vh -- /bin/bash -c "rm -f .${DATABASESERVER}.sql.$$"
    else
      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE} ${DB_FILE}
    fi
  elif [ "${DB_OP}" == "" ]; then
    doDatabaseConnectMessage
set -x
    
    kubectl exec -it $(wov-p ${DATABASESERVER}-${WOV_STAGE} ) -- sh -c "mongo --quiet ${DB_DATABASE}"
#    if [ "${DB_HOST}" != "localhost" ]; then
#      kubectl exec  -it vh -- /bin/bash -c "mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE}"
#    else
#      mongo --quiet mongodb://${DB_HOST}/${DB_DATABASE}
#    fi
set +x

  fi

else
  printf "\n\nERROR: Unknown database type of '${DB_TYPE}'. Probably need to implement it in wov-db-connect, and ensure it is supported in vh container.\n"
  exit 1
fi


